<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hex Conquest</title>
    <style>
        /* Basic Styles */
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        .action-buttons, .control-buttons, .color-selection, .log-container {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            z-index: 2000; /* Higher z-index to ensure visibility */
        }
        /* Control Buttons Container */
        .control-buttons {
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px; /* Space between buttons */
            width: 150px; /* Fixed width for consistency */
        }
        /* Color Selection */
        .color-selection {
            top: 10px;
            left: 220px;
            z-index: 1002; /* Higher than control-buttons */
            padding: 15px;
            border-radius: 8px;
            max-width: 400px;
            display: none; /* Hidden initially */
        }
        /* Log Container */
        .log-container {
            bottom: 0;
            left: 0;
            width: 100%;
            max-height: 150px;
            overflow-y: auto;
            background-color: #fff;
            padding: 5px;
            box-sizing: border-box;
            font-size: 14px;
            border-top: 1px solid #ccc;
            z-index: 10;
        }
        /* Action Buttons Styling */
        .action-button {
            padding: 10px 0; /* Vertical padding for consistent height */
            font-size: 14px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            color: #fff;
            transition: opacity 0.3s;
            width: 100%;
            text-align: center; /* Center text horizontally */
        }
        .action-button:hover:not(:disabled) {
            opacity: 0.8;
        }
        .action-button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        /* SVG Styling */
        svg {
            width: 100%;
            height: 100%;
        }
        .hex {
            stroke-width: 2;
            stroke: #000;
            fill: #e0e0e0;
            cursor: pointer;
            transition: fill 0.3s, stroke 0.3s;
        }
        .hex:hover {
            fill: #d0d0d0;
        }
        .hex.highlighted {
            stroke-width: 5;
        }
        .unit {
            pointer-events: none;
        }
        .unit-circle {
            stroke: #000;
            stroke-width: 1;
        }
        .unit-text {
            font-size: 14px;
            font-weight: bold;
            fill: #fff;
            text-anchor: middle;
            /*dominant-baseline: middle;*/
            pointer-events: none;
        }
        .trail-line {
            stroke: rgba(0, 0, 0, 0.5);
            stroke-width: 2;
            stroke-dasharray: 4;
        }
        .fire-icon {
            pointer-events: none;
            opacity: 0.8;
            transition: opacity 0.5s, r 0.5s;
            stroke: #000; /* Black stroke for visibility */
            stroke-width: 1;
        }
        /* Styles for Color Selection */
        .color-buttons {
            display: flex;
            flex-direction: row;
            gap: 10px; /* Space between buttons */
            flex-wrap: wrap; /* Wrap to next line if necessary */
            margin-top: 10px;
        }
        .selected-color {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        .selected-color span {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: inline-block;
            border: 2px solid #000;
        }
        .current-player {
            margin-bottom: 10px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>

    <script>
        // Define constants
        const NUM_PLAYERS = 2;
        const GRID_SIZE = 4;  // Radius for diameter=7
        const MAX_TURNS = 15; // Adjusted max turns for larger grid
        const TILE_SIZE = 40; // Adjusted tile size to fit larger grid

        const gameContainer = document.getElementById('game-container');

        // Create SVG element for the game board
        const svgNS = "http://www.w3.org/2000/svg";
        let svg = document.createElementNS(svgNS, 'svg');
        gameContainer.appendChild(svg);

        // Define game states
        const GameState = {
            Idle: 'Idle',
            SelectingAction: 'SelectingAction',
            SelectingMoveTarget: 'SelectingMoveTarget',
            SelectingAttackTarget: 'SelectingAttackTarget'
        };

        let game = {};

        // Initialize the game
        initGame();

        function initGame() {
            console.log("Initializing game...");
            // Reset the game state
            game = {
                grid: {},
                players: [], // Array to hold player objects
                turn: 1,
                playerActions: Array(NUM_PLAYERS).fill(null).map(() => []), // Actions for each player
                availableColors: ['#4CAF50', '#0000FF', '#FFA500', '#800080', '#FF0000', '#00FFFF'], // Green, Blue, Orange, Purple, Red, Cyan
                trails: [],
                fires: [],
                attackLines: [] // Add attackLines array
            };
            // Clear existing SVG and create a new one
            if (svg) {
                gameContainer.removeChild(svg);
            }
            svg = document.createElementNS(svgNS, 'svg');
            gameContainer.appendChild(svg);
            // Remove existing UI elements
            removeAllUIElements();
            // Reset state
            currentState = GameState.Idle;
            selectedUnit = null;
            // Show color selection
            showColorSelection();
        }

        function removeAllUIElements() {
            // Remove action-buttons
            const actionButtons = document.querySelector('.action-buttons');
            if (actionButtons) {
                gameContainer.removeChild(actionButtons);
            }
            // Remove control-buttons
            const controlButtons = document.querySelector('.control-buttons');
            if (controlButtons) {
                gameContainer.removeChild(controlButtons);
            }
            // Remove color-selection
            const colorSelection = document.querySelector('.color-selection');
            if (colorSelection) {
                gameContainer.removeChild(colorSelection);
            }
            // Remove log-container
            const logContainer = document.querySelector('.log-container');
            if (logContainer) {
                gameContainer.removeChild(logContainer);
            }
        }

        function createContainer(className, styles = {}) {
            const container = document.createElement('div');
            container.classList.add(className);
            Object.assign(container.style, styles);
            return container;
        }

        function showColorSelection() {
            console.log("Showing color selection...");
            const colorSelectionContainer = createContainer('color-selection', {
                top: '10px',
                left: '220px',
                display: 'flex',
                flexDirection: 'column'
            });

            // Create and append title
            const title = document.createElement('p');
            title.innerHTML = '<strong>Select Colors for Players and Set Max Power:</strong>';
            colorSelectionContainer.appendChild(title);

            // Max Power Input
            const maxPowerLabel = document.createElement('label');
            maxPowerLabel.textContent = "Set Max Power for Units:";
            colorSelectionContainer.appendChild(maxPowerLabel);

            const maxPowerInput = document.createElement('input');
            maxPowerInput.type = 'number';
            maxPowerInput.value = 2; // Default value
            maxPowerInput.min = 1;   // Minimum value
            maxPowerInput.max = 5;   // Optional: Max limit
            maxPowerInput.style.marginBottom = '10px';
            colorSelectionContainer.appendChild(maxPowerInput);

            // Player color selections for all players displayed at once
            for (let playerIndex = 0; playerIndex < NUM_PLAYERS; playerIndex++) {
                const currentPlayerDiv = document.createElement('div');
                currentPlayerDiv.classList.add('current-player');
                currentPlayerDiv.textContent = `Player ${playerIndex + 1}: Select Your Color`;

                // Create a container for color buttons with horizontal layout
                const buttonsContainer = document.createElement('div');
                buttonsContainer.classList.add('color-buttons');

                game.availableColors.forEach((color) => {
                    const colorButton = document.createElement('button');
                    colorButton.classList.add('action-button');
                    colorButton.style.backgroundColor = color;
                    colorButton.style.width = '30px';
                    colorButton.style.height = '30px';
                    colorButton.style.padding = '0'; // Remove padding for uniform size
                    colorButton.setAttribute('data-color', color); // Store color in data attribute
                    colorButton.title = color;

                    colorButton.addEventListener('click', () => {
                        if (!game.players[playerIndex]) {
                            // Assign color to the player
                            game.players[playerIndex] = {
                                playerId: playerIndex + 1,
                                units: [],
                                color: color,
                            };

                            log(`Player ${playerIndex + 1} selected color ${color}.`);

                            // Highlight the selected color button
                            colorButton.style.outline = '3px solid black';
                            colorButton.style.border = '2px solid #000';

                            // Disable other buttons for this player
                            buttonsContainer.querySelectorAll('button').forEach(btn => {
                                if (btn !== colorButton) {
                                    btn.disabled = true;
                                    btn.style.opacity = 0.5; // Make unselected buttons semi-transparent
                                }
                            });

                            // Remove selected color from availableColors for other players
                            game.availableColors = game.availableColors.filter(c => c !== color);

                            // Check if all players have selected their colors
                            checkAllPlayersSelected();
                        }
                    });

                    buttonsContainer.appendChild(colorButton);
                });

                currentPlayerDiv.appendChild(buttonsContainer);
                colorSelectionContainer.appendChild(currentPlayerDiv);
            }

            // Add the color selection container to the game
            gameContainer.appendChild(colorSelectionContainer);

            // Create Start Game Button (game will not start until pressed)
            const startGameButton = document.createElement('button');
            startGameButton.textContent = 'Start Game';
            startGameButton.classList.add('action-button');
            startGameButton.style.backgroundColor = '#4CAF50';
            startGameButton.disabled = true;  // Disabled until all players select colors
            startGameButton.style.marginTop = '10px';
            startGameButton.addEventListener('click', () => {
                game.maxPower = parseInt(maxPowerInput.value, 10);  // Store max power in game settings
                console.log(`Max power set to ${game.maxPower}`);
                startGame();
            });
            colorSelectionContainer.appendChild(startGameButton);

            // Function to enable the Start Game button when all players have selected colors
            function checkAllPlayersSelected() {
                // Check if all players have selected a color
                const allPlayersSelected = game.players.every(player => player && player.color);
                
                if (allPlayersSelected) {
                    startGameButton.disabled = false;
                }
            }

        }


        function startGame() {
            console.log("Starting game...");
            // Remove color selection container from DOM
            const colorSelection = document.querySelector('.color-selection');
            if (colorSelection) {
                gameContainer.removeChild(colorSelection);
            }
            // Create grid and players
            createGrid();
            createPlayers();
            updateDisplay();
            log("Game started. All players have selected their colors.");
            // Create Control Buttons container
            const controlButtonsContainer = createContainer('control-buttons', {
                top: '10px',
                right: '10px',
                display: 'flex',
                flexDirection: 'column',
                gap: '10px',
                width: '150px'
            });
            controlButtonsContainer.classList.add('control-buttons');

            // Create Execute Turn button
            const nextTurnButton = document.createElement('button');
            nextTurnButton.textContent = 'Execute Turn';
            nextTurnButton.classList.add('action-button');
            nextTurnButton.style.backgroundColor = '#008CBA'; // Blue
            nextTurnButton.addEventListener('click', executeTurn);
            controlButtonsContainer.appendChild(nextTurnButton);

            // Create Restart Game button
            const restartButton = document.createElement('button');
            restartButton.textContent = 'Restart Game';
            restartButton.classList.add('action-button');
            restartButton.style.backgroundColor = '#f44336'; // Red
            restartButton.addEventListener('click', initGame);
            controlButtonsContainer.appendChild(restartButton);

            gameContainer.appendChild(controlButtonsContainer);

            // Create Log container
            const logContainer = createContainer('log-container', {
                bottom: '0',
                left: '0',
                width: '100%',
                maxHeight: '150px',
                overflowY: 'auto',
                backgroundColor: '#fff',
                padding: '5px',
                boxSizing: 'border-box',
                fontSize: '14px',
                borderTop: '1px solid #ccc'
            });
            gameContainer.appendChild(logContainer);

            game.logContainer = logContainer;
        }

        function createGrid() {
            console.log("Creating grid...");
            for (let q = -GRID_SIZE + 1; q <= GRID_SIZE - 1; q++) {
                for (let r = -GRID_SIZE + 1; r <= GRID_SIZE - 1; r++) {
                    const s = -q - r;
                    if (Math.abs(s) < GRID_SIZE) {
                        const tile = createHexTile(q, r);
                        game.grid[`${q},${r}`] = tile;
                    }
                }
            }
        }

        function createHexTile(q, r) {
            const tile = {
                q: q,
                r: r,
                s: -q - r,
                unit: null,
                owner: null,
                element: null,
            };
            const { x, y } = hexToPixel(q, r);
            const points = polygonPoints(6, TILE_SIZE, x, y);
            const hex = document.createElementNS(svgNS, 'polygon');
            hex.setAttribute('points', points);
            hex.setAttribute('class', 'hex');
            hex.dataset.q = q;
            hex.dataset.r = r;
            tile.element = hex;
            svg.appendChild(hex);
            // Attach tile reference for event handlingƒ
            hex.tile = tile;
            hex.addEventListener('click', handleTileClick);
            return tile;
        }

        function createPlayers() {
            console.log("Creating players and placing initial units...");
            const startPositions = [
                [0, -GRID_SIZE + 1], 
                [0, GRID_SIZE - 1]
            ];
            for (let i = 0; i < NUM_PLAYERS; i++) {
                const [q, r] = startPositions[i];
                const tile = game.grid[`${q},${r}`];
                const player = game.players[i];
                const unit = {
                    playerId: player.playerId,
                    strength: 1,
                    tile: tile,
                    power: 1, // Initialize power units to one for attacks
                    isMoving: false,
                };
                tile.unit = unit;
                tile.owner = player.playerId;
                player.units.push(unit);
                console.log(`Player ${player.playerId} unit placed at (${q}, ${r})`);
            }
        }

        function hexToPixel(q, r) {
            const size = TILE_SIZE;
            const x = size * (Math.sqrt(3) * q + Math.sqrt(3)/2 * r) + window.innerWidth / 2;
            const y = size * (3/2 * r) + window.innerHeight / 2;
            return { x, y };
        }

        function polygonPoints(sides, radius, centerX, centerY) {
            let points = '';
            for (let i = 0; i < sides; i++) {
                const angle_deg = 60 * i - 30;
                const angle_rad = Math.PI / 180 * angle_deg;
                const x = centerX + radius * Math.cos(angle_rad);
                const y = centerY + radius * Math.sin(angle_rad);
                points += `${x},${y} `;
            }
            return points.trim();
        }

        function updateDisplay() {
            console.log("Updating display...");
            // Clear existing units by removing all unit elements
            const existingUnits = svg.querySelectorAll('.unit, .unit-text');
            existingUnits.forEach(unit => svg.removeChild(unit));

            // Trails and fires are not cleared here to keep them visible until next turn

            for (const key in game.grid) {
                const tile = game.grid[key];
                const hex = tile.element;
                // Update fill color based on ownership
                if (tile.owner) {
                    const player = game.players.find(p => p.playerId === tile.owner);
                    hex.setAttribute('fill', player.color);
                } else {
                    hex.setAttribute('fill', '#e0e0e0');
                }
                // Reset stroke
                hex.setAttribute('stroke', '#000');
                hex.setAttribute('stroke-width', '2');
                hex.classList.remove('highlighted');
                // Add unit circle if unit exists
                if (tile.unit) {
                    const { x, y } = hexToPixel(tile.q, tile.r);
                    const unitCircle = document.createElementNS(svgNS, 'circle');
                    unitCircle.setAttribute('cx', x);
                    unitCircle.setAttribute('cy', y);
                    unitCircle.setAttribute('r', TILE_SIZE / 2 - 5);
                    unitCircle.setAttribute('fill', getPlayerColor(tile.unit.playerId));
                    unitCircle.setAttribute('class', 'unit unit-circle');
                    svg.appendChild(unitCircle);

                    // Display power units as text
                    const unitText = document.createElementNS(svgNS, 'text');
                    unitText.setAttribute('x', x);
                    unitText.setAttribute('y', y + 5); // Adjusted for visual centering
                    unitText.textContent = tile.unit.power;
                    unitText.setAttribute('class', 'unit unit-text');
                    svg.appendChild(unitText);

                    console.log(`Unit displayed at (${tile.q}, ${tile.r}) with power ${tile.unit.power}`);
                }
            }
        }

        function getPlayerColor(playerId) {
            const player = game.players.find(p => p.playerId === playerId);
            return player.color;
        }

        // Named function for handling tile clicks based on current state
        function handleTileClick(event) {
            const tile = event.currentTarget.tile;
            console.log(`Tile clicked: (${tile.q}, ${tile.r}), Owner: ${tile.owner}, Unit Present: ${tile.unit !== null}`);

            if (currentState === GameState.Idle) {
                // Idle state: Selecting a unit to perform an action
                if (!tile.owner || tile.unit === null) {
                    log(`Cannot select this tile. It has no unit.`);
                    return;
                }
                // Highlight selected unit
                unhighlightAllTiles();
                bringTileToFront(tile, 'yellow');

                // Set selected unit and transition to SelectingAction state
                selectedUnit = tile.unit;
                currentState = GameState.SelectingAction;
                // Show action buttons for the unit
                showUnitActionButtons(selectedUnit);
            } else if (currentState === GameState.SelectingMoveTarget) {
                // Selecting target tile for Move action
                if (tile.owner || tile.unit !== null) {
                    log(`Cannot move to (${tile.q}, ${tile.r}). Tile is occupied.`);
                    return;
                }
                const distance = hexDistance(selectedUnit.tile.q, selectedUnit.tile.r, tile.q, tile.r);
                if (distance !== 1) {
                    log(`Cannot move to (${tile.q}, ${tile.r}). It is not adjacent.`);
                    return;
                }
                // Plan the move action
                planAction(selectedUnit.playerId - 1, selectedUnit, 'move', tile);
                log(`Player ${selectedUnit.playerId} planned to move to (${tile.q}, ${tile.r}).`);
                // Reset state and UI
                removeAllActionButtons();
                currentState = GameState.Idle;
                selectedUnit = null;
                unhighlightAllTiles();
            } else if (currentState === GameState.SelectingAttackTarget) {
                // Selecting target tile for Attack action
                if (tile.owner === selectedUnit.playerId) {
                    log(`Cannot attack your own unit at (${tile.q}, ${tile.r}).`);
                    return;
                }
                const distance = hexDistance(selectedUnit.tile.q, selectedUnit.tile.r, tile.q, tile.r);
                if (distance !== 1) {
                    log(`Cannot attack (${tile.q}, ${tile.r}). It is not adjacent.`);
                    return;
                }
                // Plan the attack action
                planAction(selectedUnit.playerId - 1, selectedUnit, 'attack', tile);
                log(`Player ${selectedUnit.playerId} planned to attack (${tile.q}, ${tile.r}).`);
                // Reset state and UI
                removeAllActionButtons();
                currentState = GameState.Idle;
                selectedUnit = null;
                unhighlightAllTiles();
            }
        }

        function bringTileToFront(tile, color) {
            // Move the tile's SVG element to the end of its parent container (SVG)
            svg.appendChild(tile.element);
            highlightTile(tile, color);

            // If the tile has a unit, also bring the unit elements to the front
            if (tile.unit) {
                const { q, r } = tile;
                const { x, y } = hexToPixel(q, r);

                // Find and move the unit circle
                const unitCircle = svg.querySelector(`circle[cx="${x}"][cy="${y}"]`);
                if (unitCircle) {
                    svg.appendChild(unitCircle);
                }

                // Find and move the unit text
                const unitText = svg.querySelector(`text[x="${x}"][y="${y + 5}"]`);
                if (unitText) {
                    svg.appendChild(unitText);
                }
            }
        }

        function showUnitActionButtons(unit) {
            console.log(`Showing action buttons for unit at (${unit.tile.q}, ${unit.tile.r})`);
            // Create action-buttons container if it doesn't exist
            let actionButtons = document.querySelector('.action-buttons');
            if (!actionButtons) {
                actionButtons = createContainer('action-buttons', {
                    top: '10px',
                    left: '10px',
                    gap: '10px',
                    display: 'flex',
                    flexDirection: 'column',
                    width: '150px' // Fixed width for consistency
                });
                gameContainer.appendChild(actionButtons);
            }

            // Create Move Button
            const moveButton = document.createElement('button');
            moveButton.textContent = 'Move';
            moveButton.classList.add('action-button');
            moveButton.style.backgroundColor = '#4CAF50'; // Green
            moveButton.addEventListener('click', () => {
                currentState = GameState.SelectingMoveTarget;
                disableOtherActionButtons();
                log(`Player ${unit.playerId} is selecting a tile to move.`);
                highlightMoveTargets(unit);
            });
            actionButtons.appendChild(moveButton);

            // Create Attack Button
            const attackButton = document.createElement('button');
            attackButton.textContent = 'Attack';
            attackButton.classList.add('action-button');
            attackButton.style.backgroundColor = '#FF9800'; // Orange
            attackButton.disabled = unit.power < 1; // Disable if no power units
            attackButton.addEventListener('click', () => {
                currentState = GameState.SelectingAttackTarget;
                disableOtherActionButtons();
                log(`Player ${unit.playerId} is selecting a tile to attack.`);
                highlightAttackTargets(unit);
            });
            actionButtons.appendChild(attackButton);

            // Create Reload Button
            const reloadButton = document.createElement('button');
            reloadButton.textContent = 'Reload';
            reloadButton.classList.add('action-button');
            reloadButton.style.backgroundColor = '#9C27B0';

            // Disable the Reload button if the unit has reached the max power limit
            if (unit.power >= game.maxPower) {
                reloadButton.disabled = true;
                reloadButton.title = `Power is already at maximum (${game.maxPower})`; // Tooltip for explanation
            }

            reloadButton.addEventListener('click', () => {
                planAction(unit.playerId - 1, unit, 'reload', null);
                log(`Player ${unit.playerId} planned to reload.`);
                removeAllActionButtons();
                currentState = GameState.Idle;
                selectedUnit = null;
                unhighlightAllTiles();
            });
            actionButtons.appendChild(reloadButton);

            // Create Cancel Button
            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'Cancel';
            cancelButton.classList.add('action-button');
            cancelButton.style.backgroundColor = '#757575'; // Grey
            cancelButton.addEventListener('click', () => {
                removeAllActionButtons();
                currentState = GameState.Idle;
                selectedUnit = null;
                unhighlightAllTiles();
                log(`Action canceled.`);
            });
            actionButtons.appendChild(cancelButton);
        }

        function disableOtherActionButtons() {
            const actionButtons = document.querySelectorAll('.action-buttons .action-button');

            // Loop through all buttons and disable all except the Cancel button
            actionButtons.forEach(button => {
                if (button.textContent !== 'Cancel') {
                    button.disabled = true;
                }
            });
        }

        function removeAllActionButtons() {
            const actionButtons = document.querySelector('.action-buttons');
            if (actionButtons) {
                gameContainer.removeChild(actionButtons)
            }
        }

        function clearContainer(container) {
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
        }

        function highlightMoveTargets(unit) {
            const neighbors = getNeighbors(unit.tile.q, unit.tile.r);
            neighbors.forEach(tile => {
                if (!tile.unit) { // Can only move to empty tiles
                    bringTileToFront(tile, 'blue');
                }
            });
            bringTileToFront(unit.tile, 'yellow');
        }

        function highlightAttackTargets(unit) {
            const neighbors = getNeighbors(unit.tile.q, unit.tile.r);
            neighbors.forEach(tile => {
                if (tile.owner && tile.owner !== unit.playerId) { // Can attack enemy units
                    bringTileToFront(tile, 'red');
                } else if (!tile.owner) { // Optionally allow attacking empty tiles
                    bringTileToFront(tile, 'orange');
                }
            });
            bringTileToFront(unit.tile, 'yellow');
        }

        function planAction(playerIndex, unit, action, targetTile) {
            const actionData = {
                playerId: playerIndex + 1,
                unitId: unit.unitId,  // Assuming each unit has a unique ID
                action: action,
                targetTile: targetTile ? { q: targetTile.q, r: targetTile.r } : null // Send only tile coordinates
            };
            
            // Update local game state as needed
            game.playerActions[playerIndex].push(actionData);
        }

        function executeTurn() {
            console.log(`Executing Turn ${game.turn}...`);
            // Check if all players have planned actions for all their units
            if (!areAllPlayersReady()) {
                alert('All players must plan actions for all their units before executing the turn.');
                return;
            }

            log(`\n--- Turn ${game.turn} Execution ---`);

            // Clear trails, fires, and attack lines
            clearObjects(game.trails);
            clearObjects(game.fires);
            clearObjects(game.attackLines);

            // Process all movement actions first
            const allMoveActions = [];
            for (let i = 0; i < NUM_PLAYERS; i++) {
                game.playerActions[i].forEach(actionData => {
                    if (actionData.action === 'move') {
                        allMoveActions.push(actionData);
                    }
                });
            }
            processMovementActions(allMoveActions, () => {
                // After movements, process reload actions
                for (let i = 0; i < NUM_PLAYERS; i++) {
                    game.playerActions[i].forEach(actionData => {
                        if (actionData.action === 'reload') {
                            actionData.unit.power += 1;
                            log(`Player ${i + 1}'s unit at (${actionData.unit.tile.q}, ${actionData.unit.tile.r}) reloaded. Power is now ${actionData.unit.power}.`);
                        }
                    });
                }

                // After reloads, process attack actions
                const allAttackActions = [];
                for (let i = 0; i < NUM_PLAYERS; i++) {
                    game.playerActions[i].forEach(actionData => {
                        if (actionData.action === 'attack') {
                            allAttackActions.push(actionData);
                        }
                    });
                }
                processAttackActions(allAttackActions, () => {
                    // Clear actions for next turn
                    game.playerActions = Array(NUM_PLAYERS).fill(null).map(() => []);
                    updateDisplay();
                    game.turn += 1;
                    log(`--- Turn ${game.turn} ---`);
                });
            });
        }

        function clearObjects(objects) {
            objects.forEach(obj => {
                svg.removeChild(obj);
            });
            objects.length = 0; // Clear the array
        }

        function areAllPlayersReady() {
            for (let i = 0; i < NUM_PLAYERS; i++) {
                const player = game.players[i];
                const actions = game.playerActions[i];
                const unitCount = player.units.length;
                const actionCount = actions.length;

                // Check if the number of actions equals the number of units
                if (actionCount !== unitCount) {
                    return false;
                }

                // Additionally, ensure each unit has one action
                const unitsWithActions = new Set(actions.map(a => a.unit));
                if (unitsWithActions.size !== unitCount) {
                    return false;
                }
            }
            return true;
        }

        function processMovementActions(movementActions, callback) {
            if (movementActions.length === 0) {
                callback();
                return;
            }

            console.log(`Processing ${movementActions.length} movement actions...`);
            // Map target tiles to units attempting to move into them
            const targetMap = {};
            movementActions.forEach(actionData => {
                const key = `${actionData.targetTile.q},${actionData.targetTile.r}`;
                if (!targetMap[key]) {
                    targetMap[key] = [];
                }
                targetMap[key].push(actionData.unit);
            });

            // Determine which movements succeed
            const successfulMovements = [];
            const failedMovements = [];

            for (const key in targetMap) {
                const units = targetMap[key];
                if (units.length === 1) {
                    successfulMovements.push({ unit: units[0], targetKey: key });
                } else {
                    // Multiple units attempting to move into the same tile
                    units.forEach(unit => {
                        failedMovements.push(unit);
                        log(`Conflict at (${key}): Player ${unit.playerId}'s movement failed due to multiple units targeting the same tile.`);
                    });
                }
            }

            // Move successful units
            let movementsCompleted = 0;
            if (successfulMovements.length > 0) {
                successfulMovements.forEach(moveData => {
                    const { unit } = moveData;
                    const [q, r] = moveData.targetKey.split(',').map(Number);
                    const targetTile = game.grid[`${q},${r}`];
                    moveUnit(unit, targetTile, () => {
                        movementsCompleted++;
                        if (movementsCompleted === successfulMovements.length) {
                            updateDisplay(); // Update display after all movements
                            callback();
                        }
                    });
                });
            } else {
                updateDisplay();
                callback();
            }
        }

        function processAttackActions(attackActions, callback) {
            if (attackActions.length === 0) {
                callback();
                return;
            }

            console.log(`Processing ${attackActions.length} attack actions...`);
            const attackResults = [];

            attackActions.forEach(actionData => {
                const attacker = actionData.unit;
                const targetTile = actionData.targetTile;

                if (attacker.power < 1) {
                    log(`Player ${attacker.playerId}'s unit at (${attacker.tile.q}, ${attacker.tile.r}) does not have enough power to attack.`);
                    return;
                }
                attacker.power -= 1; // Consume one power unit

                // Always apply the attack if there is a defender on the target tile
                const defender = targetTile.unit;
                if (defender && defender.playerId !== attacker.playerId) {
                    // Simplified outcome: defender lose 1 strength
                    defender.strength -= 1;

                    log(`Attack hit! Player ${attacker.playerId}'s unit at (${attacker.tile.q}, ${attacker.tile.r}) attacked Player ${defender.playerId}'s unit at (${defender.tile.q}, ${defender.tile.r}).`);
                    console.log(`Before attack: Attacker Strength=${attacker.strength + 1}, Defender Strength=${defender.strength + 1}`);

                    if (defender.strength <= 0) {
                        // Defender is defeated
                        defender.tile.unit = null;
                        defender.tile.owner = null;
                        log(`Player ${attacker.playerId} defeated Player ${defender.playerId} at (${defender.tile.q}, ${defender.tile.r}).`);
                        removeUnitFromPlayer(defender);
                    }

                    if (attacker.strength <= 0) {
                        // Attacker is defeated
                        attacker.tile.unit = null;
                        attacker.tile.owner = null;
                        log(`Player ${attacker.playerId}'s unit was defeated at (${attacker.tile.q}, ${attacker.tile.r}).`);
                        removeUnitFromPlayer(attacker);
                    }

                    attackResults.push({
                        attacker: attacker,
                        targetTile: targetTile,
                        outcome: 'hit'
                    });
                } else {
                    log(`Player ${attacker.playerId} attacked empty tile at (${targetTile.q}, ${targetTile.r}) but nothing was there.`);
                    attackResults.push({
                        attacker: attacker,
                        targetTile: targetTile,
                        outcome: 'miss_empty'
                    });
                }

                // Add attack line animation
                createAttackLine(attacker, targetTile);
            });

            // Resolve all attack results and create fire icons
            attackResults.forEach(result => {
                const { attacker, targetTile, outcome } = result;

                const targetPixel = hexToPixel(targetTile.q, targetTile.r);

                // Create the fire icon
                const fireIcon = document.createElementNS(svgNS, 'circle');
                fireIcon.setAttribute('cx', targetPixel.x);
                fireIcon.setAttribute('cy', targetPixel.y);
                fireIcon.setAttribute('r', TILE_SIZE / 2 - 15); // Adjust size as needed
                fireIcon.setAttribute('class', 'fire-icon');

                // Set fire color based on outcome
                if (outcome === 'hit') {
                    fireIcon.setAttribute('fill', getPlayerColor(attacker.playerId)); // Use attacker's color
                } else if (outcome === 'miss_empty') {
                    fireIcon.setAttribute('fill', '#FFD700'); // Gold color for empty hit
                }

                svg.appendChild(fireIcon);
                game.fires.push(fireIcon);

                console.log(`Fire icon created at (${targetTile.q}, ${targetTile.r}) with color ${fireIcon.getAttribute('fill')}`);
            });

            callback();
        }

        function createAttackLine(attacker, targetTile) {
            const attackerPixel = hexToPixel(attacker.tile.q, attacker.tile.r);
            const targetPixel = hexToPixel(targetTile.q, targetTile.r);

            // Create the attack line
            const attackLine = document.createElementNS(svgNS, 'line');
            attackLine.setAttribute('x1', attackerPixel.x);
            attackLine.setAttribute('y1', attackerPixel.y);
            attackLine.setAttribute('x2', attackerPixel.x); // Initially at attacker's position
            attackLine.setAttribute('y2', attackerPixel.y); // Initially at attacker's position
            attackLine.setAttribute('stroke', getPlayerColor(attacker.playerId));
            attackLine.setAttribute('stroke-width', '3');
            attackLine.setAttribute('stroke-dasharray', '5, 5'); // Dashed line for attack effect

            svg.appendChild(attackLine);
            game.attackLines.push(attackLine); // Persist the attack line

            // Animate the line to move from the attacker to the target
            const duration = 500; // Animation duration in milliseconds
            const startTime = performance.now();

            function animate() {
                const currentTime = performance.now();
                const elapsedTime = currentTime - startTime;
                const t = Math.min(elapsedTime / duration, 1); // Normalize time to [0, 1]

                const currentX = attackerPixel.x + (targetPixel.x - attackerPixel.x) * t;
                const currentY = attackerPixel.y + (targetPixel.y - attackerPixel.y) * t;

                attackLine.setAttribute('x2', currentX);
                attackLine.setAttribute('y2', currentY);

                if (t < 1) {
                    requestAnimationFrame(animate);
                }
            }

            animate();
        }

        function moveUnit(unit, targetTile, callback) {
            const currentTile = unit.tile;
            const { x: fromX, y: fromY } = hexToPixel(currentTile.q, currentTile.r);
            const { x: toX, y: toY } = hexToPixel(targetTile.q, targetTile.r);

            // Remove unit's visual representation from the current tile before animation
            removeUnitVisuals(currentTile);

            // Update tile ownership and unit placement
            currentTile.unit = null;
            currentTile.owner = null; // Clear ownership if no other units are present
            targetTile.unit = unit;
            targetTile.owner = unit.playerId;
            unit.tile = targetTile; // Correctly update the unit's current tile

            // Create trail line
            const trailLine = document.createElementNS(svgNS, 'line');
            trailLine.setAttribute('x1', fromX);
            trailLine.setAttribute('y1', fromY);
            trailLine.setAttribute('x2', toX);
            trailLine.setAttribute('y2', toY);
            trailLine.setAttribute('class', 'trail-line');
            svg.appendChild(trailLine);
            // Store the trail to remove it at the beginning of the next turn
            game.trails.push(trailLine);

            // Animation
            const unitCircle = document.createElementNS(svgNS, 'circle');
            unitCircle.setAttribute('cx', fromX);
            unitCircle.setAttribute('cy', fromY);
            unitCircle.setAttribute('r', TILE_SIZE / 2 - 5);
            unitCircle.setAttribute('fill', getPlayerColor(unit.playerId));
            unitCircle.setAttribute('class', 'unit unit-circle');
            svg.appendChild(unitCircle);

            // Display power units as text
            const unitText = document.createElementNS(svgNS, 'text');
            unitText.setAttribute('x', fromX);
            unitText.setAttribute('y', fromY + 5);
            unitText.textContent = unit.power;
            unitText.setAttribute('class', 'unit unit-text');
            svg.appendChild(unitText);

            const duration = 1000; // Animation duration in milliseconds
            const startTime = performance.now();

            function animate() {
                const currentTime = performance.now();
                const elapsedTime = currentTime - startTime;
                const t = Math.min(elapsedTime / duration, 1); // Normalized time [0,1]

                const currentX = fromX + (toX - fromX) * t;
                const currentY = fromY + (toY - fromY) * t;

                unitCircle.setAttribute('cx', currentX);
                unitCircle.setAttribute('cy', currentY);
                unitText.setAttribute('x', currentX);
                unitText.setAttribute('y', currentY + 5);

                if (t < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Animation complete
                    svg.removeChild(unitCircle);
                    svg.removeChild(unitText);
                    console.log(`Unit movement complete. New position: (${unit.tile.q}, ${unit.tile.r})`);
                    if (callback) callback();
                }
            }

            animate();

            log(`Player ${unit.playerId} moved to (${targetTile.q}, ${targetTile.r})`);
        }

        function removeUnitVisuals(tile) {
            const { q, r } = tile;
            const { x, y } = hexToPixel(q, r);

            // Find and remove the unit circle and unit text at this position
            const unitCircle = svg.querySelector(`circle[cx="${x}"][cy="${y}"]`);
            const unitText = svg.querySelector(`text[x="${x}"][y="${y + 5}"]`);

            if (unitCircle) {
                svg.removeChild(unitCircle);
            }
            if (unitText) {
                svg.removeChild(unitText);
            }

            console.log(`Unit visuals removed from tile (${q}, ${r})`);
        }

        function removeUnitFromPlayer(unit) {
            const player = game.players.find(p => p.playerId === unit.playerId);
            const index = player.units.indexOf(unit);
            if (index > -1) {
                player.units.splice(index, 1);
                console.log(`Unit removed from Player ${player.playerId}'s unit list.`);
            }
        }

        function getNeighbors(q, r) {
            const directions = [
                [1, 0], [0, 1], [-1, 1],
                [-1, 0], [0, -1], [1, -1],
            ];
            const neighbors = [];
            directions.forEach(dir => {
                const nq = q + dir[0];
                const nr = r + dir[1];
                const neighbor = game.grid[`${nq},${nr}`];
                if (neighbor) {
                    neighbors.push(neighbor);
                }
            });
            return neighbors;
        }

        function highlightTile(tile, color) {
            tile.element.setAttribute('stroke', color);
            tile.element.setAttribute('stroke-width', '5');
            tile.element.classList.add('highlighted');
        }

        function unhighlightAllTiles() {
            for (const key in game.grid) {
                const tile = game.grid[key];
                tile.element.setAttribute('stroke', '#000');
                tile.element.setAttribute('stroke-width', '2');
                tile.element.classList.remove('highlighted');
            }
        }

        function log(message) {
            if (!game.logContainer) {
                // Create log container if it doesn't exist
                const logContainer = createContainer('log-container', {
                    bottom: '0',
                    left: '0',
                    width: '100%',
                    maxHeight: '150px',
                    overflowY: 'auto',
                    backgroundColor: '#fff',
                    padding: '5px',
                    boxSizing: 'border-box',
                    fontSize: '14px',
                    borderTop: '1px solid #ccc'
                });
                gameContainer.appendChild(logContainer);
                game.logContainer = logContainer;
            }
            const p = document.createElement('p');
            p.textContent = message;
            game.logContainer.appendChild(p);
            game.logContainer.scrollTop = game.logContainer.scrollHeight;
            console.log(message); // Also log to console for debugging
        }

        function hexDistance(q1, r1, q2, r2) {
            return (Math.abs(q1 - q2) + Math.abs(r1 - r2) + Math.abs((-q1 - r1) - (-q2 - r2))) / 2;
        }
    </script>
</body>
</html>
