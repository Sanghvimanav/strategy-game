<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hex Conquest</title>
    <style>
        /* Basic Styles */
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            /*overflow: hidden;  Prevent scrolling on the entire viewport */
        }

        #scroll-container {
            width: 100%;
            height: 100%; /* Adjust as needed to support the size of your game board */
            overflow: scroll; /* Allow scrolling within this container */
            position: relative;
        }

        /*svg {
            width: 100%;
            height: 100%;
        }*/

        .action-buttons, .control-buttons, .color-selection, .log-container {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            z-index: 2000; /* Higher z-index to ensure visibility */
        }
        /* Control Buttons Container */
        .control-buttons {
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px; /* Space between buttons */
            width: 150px; /* Fixed width for consistency */
        }
        /* Turn Counter Styling */
        .turn-counter {
            text-align: center;
            font-size: 16px;
            font-weight: bold;
            padding: 10px;
        }
        .move-attack-line {
            stroke-linecap: round;
            opacity: 0.8;
        }


        /* Color Selection */
        .color-selection {
            top: 10px;
            left: 220px;
            z-index: 1002; /* Higher than control-buttons */
            padding: 15px;
            border-radius: 8px;
            max-width: 400px;
            display: none; /* Hidden initially */
        }
        /* Log Container */
        .log-container {
            bottom: 0;
            left: 0;
            width: 100%;
            max-height: 150px;
            overflow-y: auto;
            background-color: #fff;
            padding: 5px;
            box-sizing: border-box;
            font-size: 14px;
            border-top: 1px solid #ccc;
        }
        /* Action Buttons Container */
        .action-buttons {
            position: absolute;
            top: 10px;
            left: 220px;
            display: flex;
            flex-direction: column;
            width: 200px;
            z-index: 1001;
        }

        /* Action Group Styling */
        /* Add gap to the action group container */
        .action-group {
            display: flex;
            flex-direction: column;
            gap: 5px; /* Adds a 5px gap between buttons */
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 8px;
            position: relative;
            margin-bottom: 10px;
        }

        /* Type Label Styling */
        .action-group .type-label {
            position: absolute;
            top: -12px;
            left: 10px;
            background-color: #fff;
            padding: 0 5px;
            font-weight: bold;
            color: #333;
        }
        /* Action Buttons Styling */
        .action-button {
            padding: 10px 0; /* Vertical padding for consistent height */
            font-size: 14px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            color: #fff;
            transition: opacity 0.3s;
            width: 100%;
            text-align: center; /* Center text horizontally */
        }
        .action-button:hover:not(:disabled) {
            opacity: 0.8;
        }
        .action-button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        /* SVG Styling */
        svg {
            width: 120%;
            height: 120%;
        }
        .hex {
            stroke: #000;
            stroke-width: 2;
            cursor: pointer;
            transition: fill 0.3s, stroke 0.3s;
        }
        .hex:hover {
            fill: #d0d0d0;
        }
        .hex.highlighted {
            stroke-width: 5;
        }
        .unit {
            pointer-events: none;
        }
        .unit-circle {
            stroke: #000;
            stroke-width: 1;
        }
        .unit-text {
            font-size: 14px; /* Increased font size for better visibility */
            font-weight: bold;
            fill: #fff;
            text-anchor: middle;
            pointer-events: none;
        }
        .trail-line {
            stroke: rgba(0, 0, 0, 0.5);
            stroke-width: 2;
            stroke-dasharray: 4;
        }
        .tile-possible {
            cursor: pointer;
        }

        .tile-selected {
            cursor: pointer;
        }
        /* Styles for Color Selection */
        .color-buttons {
            display: flex;
            flex-direction: row;
            gap: 10px; /* Space between buttons */
            flex-wrap: wrap; /* Wrap to next line if necessary */
            margin-top: 10px;
        }
        .selected-color {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        .selected-color span {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: inline-block;
            border: 2px solid #000;
        }
        .current-player {
            margin-bottom: 10px;
            font-weight: bold;
        }
        .trail-line {
            stroke: rgba(0, 0, 0, 0.5);
            stroke-width: 2;
            stroke-dasharray: 4;
        }

        /* Units Panel Styling */
        .units-panel {
            position: absolute; /* Ensure it's positioned relative to the game-container */
            top: 10px;
            left: 10px;
            width: 200px;
            max-height: 400px;
            overflow-y: auto;
            background-color: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            z-index: 1001; /* Above game board but below modals */
        }
        .units-panel h3 {
            margin-top: 0;
            text-align: center;
            font-size: 16px;
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
        }
        #units-list {
            list-style-type: none;  /* Remove bullet points */
            padding: 0;  /* Remove padding */
            margin: 0;   /* Remove margin */
        }       
        .unit-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 5px;
            margin: 5px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9;
        }
        .unit-item.your-unit {
            background-color: #e0f7fa; /* Light cyan for player's units */
            cursor: pointer;
        }
        .unit-item.other-unit {
            background-color: #f1f1f1;
            color: #888;
        }
        .unit-item.selected {
            border: 2px solid #2196F3;
            background-color: #b3e5fc; /* Slightly darker blue */
        }
        .unit-item.disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .attack-line {
            /*stroke: rgba(255, 0, 0, 0.8);  Red color for attacks */
            stroke-width: 3;
            stroke-dasharray: 5,5;
        }
        .color-indicator {
            width: 15px;              /* Adjusted size for better visibility */
            height: 15px;
            border-radius: 20%;       /* Makes it a perfect circle */
            display: inline-block;
            margin-right: 5px;        /* Space between the indicator and text */
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="scroll-container"></div>
    </div>

    <script>
        // Define constants
        const NUM_PLAYERS = 2;
        const TILE_SIZE = 40; // Tile size

        const gameContainer = document.getElementById('game-container');
        const scrollContainer = document.getElementById('scroll-container');

        // Create SVG element for the game board
        const svgNS = "http://www.w3.org/2000/svg";
        let svg = document.createElementNS(svgNS, 'svg');
        scrollContainer.appendChild(svg);

        let gameState = {};
        let playerId = null;
        let playerColor = null;
        let maxPower = 2; // Default max power
        let unitsMap = {}; // Global mapping from tile key to unit
        let selectedActionDef = null;
        let currentActionDef = null;
        let actionMode = null; // 'move' or 'attack'
        let selectedUnit = null;
        let movementPath = []; // Global variable to store the movement path
        let isInitialCenterSet = false;

        // Connect to the WebSocket server
        const socket = new WebSocket('ws://127.0.0.1:8080'); //localhost
        //const socket = new WebSocket('ws://192.168.0.182:8080'); // Joseph's IP
        //const socket = new WebSocket('ws://192.168.0.106:8080'); // Manav's IP
        //const socket = new WebSocket('ws://192.168.0.102:8080'); // Quinn's IP

        // Listen for messages from the server
        socket.addEventListener('message', function (event) {
            const message = JSON.parse(event.data);
            console.log('Message from server:', message);

            if (message.type === 'welcome') {
                playerId = message.playerId;
                showColorSelection(message.availableColors);
                
                // If player 1, show game type selection options
                if (playerId === 1) {
                    console.log('playerId is 1')
                    showGameTypeSelection(message.gameTypes);
                }
            }

            if (message.type === 'actions_list') {
                // Store the received actions list
                window.ACTIONS = message.actions; // Make ACTIONS globally accessible
                console.log('Received ACTIONS list from server:', ACTIONS);
            }

            if (message.type === 'game_type_selected') {
                log(`Game type selected: ${message.gameType}`);
            }

            if (message.type === 'color_selected') {
                playerColor = message.color;
                log(`You selected color ${playerColor}. Waiting for other players...`);
                //updatePlayerInfo(playerId, playerColor);  // Update player info after color selection
            }

            if (message.type === 'init') {
                // Not used in this refactored version
            }

            if (message.type === 'update') {
                // Update game state and render
                gameState = message.state;
                updateDisplay();
                // Remove or hide the color selection UI after game starts
                removeColorSelection();
            }

            if (message.type === 'player_action') {
                //console.log(message)
                playerIndex = message.action.playerId - 1
                gameState.playerActions[playerIndex] = message.action.playerAction
                //console.log(gameState.playerActions)
            }

            if (message.type === 'game_over') {
                updateDisplay();
                handleGameOver(message.winner);
            }

            if (message.type === 'error') {
                alert(`Error: ${message.message}`);
            }
        });

        function showGameTypeSelection(gameTypes) {
            const gameTypeSelectionContainer = document.createElement('div');
            gameTypeSelectionContainer.classList.add('game-type-selection');
            gameTypeSelectionContainer.innerHTML = '<h3>Select Game Type:</h3>';

            gameTypes.forEach(gameType => {
                const gameTypeButton = document.createElement('button');
                gameTypeButton.textContent = `${gameType.name}: ${gameType.description}`;
                gameTypeButton.addEventListener('click', () => {
                    selectGameType(gameType.typeKey);
                });

                gameTypeSelectionContainer.appendChild(gameTypeButton);
            });

            // Set styles to position the container at the top center
            Object.assign(gameTypeSelectionContainer.style, {
                position: 'absolute',
                top: '10px',
                left: '50%',
                transform: 'translateX(-50%)', // Center horizontally
                zIndex: '2000',
                backgroundColor: 'rgba(255, 255, 255, 0.95)',
                padding: '15px',
                borderRadius: '8px',
                boxShadow: '0 0 10px rgba(0,0,0,0.3)',
            });

            document.body.appendChild(gameTypeSelectionContainer);
        }


        function selectGameType(gameTypeKey) {
            socket.send(JSON.stringify({ type: 'game_type_selection', gameType: gameTypeKey }));
            log(`Player 1 selected game type: ${gameTypeKey}`);
            const gameTypeSelectionContainer = document.querySelector('.game-type-selection');
            if (gameTypeSelectionContainer) {
                gameTypeSelectionContainer.remove();
            }
        }

        function removeColorSelection() {
            const colorSelection = document.querySelector('.color-selection');
            if (colorSelection) {
                gameContainer.removeChild(colorSelection);
            }
        }

        // Send color selection to the server
        function sendColorSelection(color) {
            const data = {
                type: 'color_selection',
                color: color
            };

            socket.send(JSON.stringify(data));
        }

        // Send player actions to the server
        function sendPlayerActions(actions) {
            socket.send(JSON.stringify({
                type: 'action',
                action: actions
            }));

            // Highlight the unit's border in green after an action is recorded
            const unitItem = document.querySelector(`.unit-item[data-unit-id="${actions.unitId}"]`);
            if (unitItem) {
                unitItem.style.border = '3px solid green';  // Highlight the border in green
            }
        }

        // Handle game over
        function handleGameOver(winnerId) {
            updateDisplay();
            if (winnerId) {
                alert(`Game Over! Player ${winnerId} wins the game!`);
            } else {
                alert(`Game Over! The game ended in a draw or due to turn limit.`);
            }
            // Optionally, display a restart button or disable further interactions
        }

        function createUnitsMap() {
            const map = {};
            gameState.players.forEach(player => {
                player.units.forEach(unit => {
                    const key = `${unit.tile.q},${unit.tile.r}`;
                    if (!map[key]) {
                        map[key] = [];
                    }
                    map[key].push(unit);
                });
            });
            return map;
        }

        // Initialize the game on connection
        function initGame() {
            // Clear existing SVG and UI elements
            if (svg) {
                scrollContainer.removeChild(svg);
            }
            svg = document.createElementNS(svgNS, 'svg');
            scrollContainer.appendChild(svg);
            removeAllUIElements();

            // Create the Units Panel for showing all units in the top-left corner
            const unitsPanel = createContainer('units-panel', {
                position: 'absolute',
                top: '10px',
                left: '10px',
                width: '180px',
                maxHeight: '400px',
                overflowY: 'auto',
                backgroundColor: 'rgba(255, 255, 255, 0.95)',
                padding: '10px',
                borderRadius: '5px',
                boxShadow: '0 0 10px rgba(0, 0, 0, 0.3)',
                zIndex: '1001', // Ensures it's above the game board
            });

            const panelTitle = document.createElement('h3');
            panelTitle.textContent = 'All Units';
            unitsPanel.appendChild(panelTitle);

            const unitsList = document.createElement('ul');
            unitsList.id = 'units-list'; // We will populate this dynamically
            unitsPanel.appendChild(unitsList);

            gameContainer.appendChild(unitsPanel);

            // Create Control Buttons container
            const controlButtonsContainer = createContainer('control-buttons', {
                top: '10px',
                right: '10px',
                display: 'flex',
                flexDirection: 'column',
                //gap: '10px', // Space between buttons
                width: '150px' // Fixed width for consistency
            });
            controlButtonsContainer.classList.add('control-buttons');

            // Added Turn Counter
            const turnCounter = document.createElement('div');
            turnCounter.classList.add('turn-counter'); // Matches the CSS class
            turnCounter.textContent = `Turn: 1`; // Initialize with Turn 1 or appropriate default
            controlButtonsContainer.appendChild(turnCounter);
            // End of Turn Counter

            // Add Player Info element
            const playerInfo = document.createElement('div');
            playerInfo.classList.add('player-info');
            playerInfo.style.textAlign = 'center'; // Center the text
            playerInfo.style.fontSize = '16px';
            playerInfo.style.fontWeight = 'bold';
            playerInfo.style.padding = '10px';
            controlButtonsContainer.appendChild(playerInfo);

            // Create Restart Game button
            const restartButton = document.createElement('button');
            restartButton.textContent = 'Restart Game';
            restartButton.classList.add('action-button');
            restartButton.style.backgroundColor = '#f44336'; // Red
            restartButton.addEventListener('click', () => {
                restartGame();
            });
            controlButtonsContainer.appendChild(restartButton);

            gameContainer.appendChild(controlButtonsContainer);

            // Create Log container
            const logContainer = createContainer('log-container', {
                bottom: '0',
                left: '0',
                width: '100%',
                maxHeight: '150px',
                overflowY: 'auto',
                backgroundColor: '#fff',
                padding: '5px',
                boxSizing: 'border-box',
                fontSize: '14px',
                borderTop: '1px solid #ccc'
            });
            gameContainer.appendChild(logContainer);
            gameContainer.logContainer = logContainer;

            // Create groups for different layers
            const tileGroup = document.createElementNS(svgNS, 'g');  // Group for tiles
            const lineGroup = document.createElementNS(svgNS, 'g');  // Group for trail and attack lines
            const unitGroup = document.createElementNS(svgNS, 'g');  // Group for units

            svg.appendChild(tileGroup);
            svg.appendChild(lineGroup);
            svg.appendChild(unitGroup);

            // Store references to these groups
            svg.tileGroup = tileGroup;
            svg.lineGroup = lineGroup;
            svg.unitGroup = unitGroup;
        }

        // Update player info to include collected resources
        function updatePlayerInfo(playerId, playerColor) {
            const playerInfo = document.querySelector('.player-info');
            if (playerInfo) {
                const player = gameState.players.find(p => p.playerId === playerId);
                const resources = player ? player.resources : {};  // Assuming `resources` is an object

                // Create a string representation of the resources object
                const resourceString = Object.keys(resources).map(resourceName => {
                    return `${resourceName}: ${resources[resourceName]}`;
                }).join(', ');

                playerInfo.innerHTML = `
                    <div style="display: flex; align-items: center;">
                        <span class="color-indicator" style="background-color: ${playerColor};"></span>
                        <strong>Player ${playerId}</strong>
                    </div>
                    <div style="margin-top: 5px;">
                        Resources: ${resourceString || 'None'}
                    </div>
                `;
            }
        }


        function removeAllUIElements() {
            // Remove action-buttons
            const actionButtons = document.querySelector('.action-buttons');
            if (actionButtons) {
                gameContainer.removeChild(actionButtons);
            }

            // Remove control-buttons
            const controlButtons = document.querySelector('.control-buttons');
            if (controlButtons) {
                gameContainer.removeChild(controlButtons);
            }

            // Remove color-selection
            const colorSelection = document.querySelector('.color-selection');
            if (colorSelection) {
                gameContainer.removeChild(colorSelection);
            }

            // Remove log-container
            const logContainer = document.querySelector('.log-container');
            if (logContainer) {
                gameContainer.removeChild(logContainer);
            }
        }

        // Function to restart the game
        function restartGame() {
            socket.send(JSON.stringify({ type: 'restart' }));
            log("Requesting game restart...");
        }

        // Create a generic container
        function createContainer(className, styles = {}) {
            const container = document.createElement('div');
            container.classList.add(className);
            Object.assign(container.style, styles);
            return container;
        }

        // Show color selection UI
        function showColorSelection(availableColors) {
            const colorSelectionContainer = createContainer('color-selection', {
                top: '10px',
                left: '10px',
                display: 'flex',
                flexDirection: 'column'
            });

            // Create and append title
            const title = document.createElement('p');
            title.innerHTML = '<strong>Select Your Color, Number of Units, and Unit Strength:</strong>';
            colorSelectionContainer.appendChild(title);

            // Create a container for color buttons with horizontal layout
            const buttonsContainer = document.createElement('div');
            buttonsContainer.classList.add('color-buttons');

            availableColors.forEach((color) => {
                const colorButton = document.createElement('button');
                colorButton.classList.add('action-button');
                colorButton.style.backgroundColor = color;
                colorButton.style.width = '30px';
                colorButton.style.height = '30px';
                colorButton.style.padding = '0'; // Remove padding for uniform size
                colorButton.setAttribute('data-color', color); // Store color in data attribute
                colorButton.title = color;

                colorButton.addEventListener('click', () => {

                    sendColorSelection(color);
                    // Highlight the selected color button
                    colorButton.style.outline = '3px solid black';
                    colorButton.style.border = '2px solid #000';

                    // Disable other buttons
                    buttonsContainer.querySelectorAll('button').forEach(btn => {
                        if (btn !== colorButton) {
                            btn.disabled = true;
                            btn.style.opacity = 0.5;
                        }
                    });
                });

                buttonsContainer.appendChild(colorButton);
            });

            colorSelectionContainer.appendChild(buttonsContainer);

            gameContainer.appendChild(colorSelectionContainer);
        }


        // Update the game display based on the game state
        function updateDisplay() {
            console.log("Updating display...");
            clearSVG();

            // Create unitsMap
            unitsMap = createUnitsMap();

            // Calculate map bounds
            const { minX, maxX, minY, maxY } = calculateMapBounds();

            // Set SVG size and viewBox
            const svgWidth = maxX - minX + TILE_SIZE * 2; // Extra padding
            const svgHeight = maxY - minY + TILE_SIZE * 2; // Extra padding
            svg.setAttribute('width', svgWidth);
            svg.setAttribute('height', svgHeight);
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);

            // Iterate over each tile
            for (const key in gameState.grid) {
                const tile = gameState.grid[key];
                const { q, r } = tile;
                const { x, y } = hexToPixel(q, r, minX, minY);
                const points = polygonPoints(6, TILE_SIZE, x, y);

                const hex = document.createElementNS(svgNS, 'polygon');
                hex.setAttribute('points', points);
                hex.setAttribute('class', 'hex');
                hex.dataset.q = q;
                hex.dataset.r = r;

                hex.setAttribute('fill', tile.color);  // Tile type color from server
            
                // Add event listener for player interaction
                hex.addEventListener('click', handleTileClick);

                // Append tile to the tile group
                svg.tileGroup.appendChild(hex);
            }

            // Group units by tile
            const tileUnitsMap = {};
            gameState.players.forEach(player => {
                player.units.forEach(unit => {
                    const key = `${unit.tile.q},${unit.tile.r}`;
                    if (!tileUnitsMap[key]) {
                        tileUnitsMap[key] = [];
                    }
                    tileUnitsMap[key].push(unit);
                });
            });

            // Render all units per tile
            for (const key in tileUnitsMap) {
                const units = tileUnitsMap[key];
                const [q, r] = key.split(',').map(Number);
                const { x, y } = hexToPixel(q, r, minX, minY);
                renderTileUnits(q, r, units, x, y);
            }

            // Render actions from lastTurnActions
            if (gameState.lastTurnActions && gameState.lastTurnActions.length > 0) {
                gameState.lastTurnActions.forEach(action => {
                    switch (action.type) {
                        case 'move_short':
                        case 'move_long':
                            renderTrailLine(action);
                            break;
                        case 'attack_short':
                        case 'attack_long':
                            renderAttackLine(action);
                            break;
                        case 'move_attack':
                            renderMoveAttackLine(action);
                            break;
                        case 'attack_blast':
                            renderAttackBlast(action);
                            break;
                        case 'attack_mortar':
                            renderAttackMortar(action);
                            break;
                        // Add cases for other action types if needed
                    }
                });
            }

            // Update Turn Counter
            const turnCounter = document.querySelector('.turn-counter');
            if (turnCounter && typeof gameState.turn !== 'undefined') {
                turnCounter.textContent = `Turn: ${gameState.turn}`;
            }

            if (gameState && gameState.players) {
                    updatePlayerInfo(playerId, getPlayerColor(playerId));
            }

            // Update control buttons if necessary
            updateControlButtons();

            // Center the view on the map
            if (!isInitialCenterSet) {
                const centerX = (svgWidth - scrollContainer.clientWidth) / 2;
                const centerY = (svgHeight - scrollContainer.clientHeight) / 2;
                scrollContainer.scrollLeft = Math.max(0, centerX);
                scrollContainer.scrollTop = Math.max(0, centerY);
                isInitialCenterSet = true;
            }
        }

        function renderTileUnits(q, r, units, x, y) {
            const unitCount = units.length;

            // Determine if multiple players are on the same tile
            const uniquePlayers = new Set(units.map(unit => unit.playerId));
            let fillColor = '#000'; // Default color (black)

            if (uniquePlayers.size === 1) {
                // Single player on the tile
                const playerId = units[0].playerId;
                fillColor = getPlayerColor(playerId);
            } else {
                // Multiple players on the tile - apply rainbow gradient
                fillColor = 'url(#rainbowGradient)';
            }

            // Create the unit circle
            const unitCircle = document.createElementNS(svgNS, 'circle');
            unitCircle.setAttribute('cx', x);
            unitCircle.setAttribute('cy', y);
            unitCircle.setAttribute('r', TILE_SIZE / 3); // Adjusted radius for visibility
            unitCircle.setAttribute('fill', fillColor);
            unitCircle.setAttribute('class', 'unit unit-circle');

            // Create the unit count text
            const unitText = document.createElementNS(svgNS, 'text');
            unitText.setAttribute('x', x);
            unitText.setAttribute('y', y + 5); // Adjust for vertical centering
            unitText.textContent = unitCount;
            unitText.setAttribute('class', 'unit unit-text');

            // Append unit elements to the unit group
            svg.unitGroup.appendChild(unitCircle);
            svg.unitGroup.appendChild(unitText);
        }

        function renderTrailLine(action) {
            const { minX, minY } = calculateMapBounds();
            const fromPixel = hexToPixel(action.from.q, action.from.r, minX, minY);
            const toPixel = hexToPixel(action.to.q, action.to.r, minX, minY);

            const trailLine = document.createElementNS(svgNS, 'line');
            trailLine.setAttribute('x1', fromPixel.x);
            trailLine.setAttribute('y1', fromPixel.y);
            trailLine.setAttribute('x2', toPixel.x);
            trailLine.setAttribute('y2', toPixel.y);
            trailLine.setAttribute('class', 'trail-line');
            trailLine.setAttribute('stroke', getPlayerColor(action.playerId));
            trailLine.setAttribute('stroke-width', '2');
            trailLine.setAttribute('stroke-dasharray', '4');
            trailLine.setAttribute('pointer-events', 'none');

            // Append trail line to the line group
            svg.lineGroup.appendChild(trailLine);
        }

        function renderAttackBlast(action) {
            const { minX, minY } = calculateMapBounds();
            const fromPixel = hexToPixel(action.from.q, action.from.r, minX, minY);
            const aoePixels = action.aoeTiles.map(tile => hexToPixel(tile.q, tile.r, minX, minY));

            // Sort AoE pixels by angle from attacker to maintain consistent shape
            const angles = aoePixels.map(p => Math.atan2(p.y - fromPixel.y, p.x - fromPixel.x));
            const sorted = aoePixels.map((p, i) => ({ p, angle: angles[i] }))
                .sort((a, b) => a.angle - b.angle);

            const sortedAoEPixels = sorted.map(obj => obj.p);

            // Assume sortedAoEPixels[0], sortedAoEPixels[1], sortedAoEPixels[2]
            const p1 = sortedAoEPixels[0];
            const p2 = sortedAoEPixels[1];
            const p3 = sortedAoEPixels[2];

            // Create the path with a curved edge between p1 and p3, using p2 as a control point
            let pathData = `M ${fromPixel.x} ${fromPixel.y} L ${p1.x} ${p1.y} Q ${p2.x} ${p2.y} ${p3.x} ${p3.y} Z`;

            // Create the SVG path element
            const path = document.createElementNS(svgNS, 'path');
            path.setAttribute('d', pathData);
            path.setAttribute('fill', 'rgba(255, 69, 0, 0.5)'); // OrangeRed with transparency
            path.setAttribute('stroke', getPlayerColor(action.playerId)); // OrangeRed
            path.setAttribute('stroke-width', '2');
            path.setAttribute('pointer-events', 'none');

            // Append to the line group
            svg.lineGroup.appendChild(path);
        }

        function renderAttackMortar(action) {
            const { minX, minY } = calculateMapBounds();
            const { x: centerX, y: centerY } = hexToPixel(action.to.q, action.to.r, minX, minY);

            const mortarCircle = document.createElementNS(svgNS, 'circle');
            mortarCircle.setAttribute('cx', centerX);
            mortarCircle.setAttribute('cy', centerY);
            mortarCircle.setAttribute('r', TILE_SIZE * 1.5); // One tile radius
            mortarCircle.setAttribute('fill', 'rgba(255, 69, 0, 0.3)'); // Semi-transparent orange-red
            mortarCircle.setAttribute('stroke', getPlayerColor(action.playerId));
            mortarCircle.setAttribute('stroke-width', '2');
            mortarCircle.setAttribute('pointer-events', 'none');

            // Append to the line group for proper layering
            svg.lineGroup.appendChild(mortarCircle);
        }

        function renderAttackLine(attack) {
            const { minX, minY } = calculateMapBounds();
            const fromPixel = hexToPixel(attack.from.q, attack.from.r, minX, minY);
            const toPixel = hexToPixel(attack.to.q, attack.to.r, minX, minY);

            const attackLine = document.createElementNS(svgNS, 'line');
            attackLine.setAttribute('x1', fromPixel.x);
            attackLine.setAttribute('y1', fromPixel.y);
            attackLine.setAttribute('x2', toPixel.x);
            attackLine.setAttribute('y2', toPixel.y);
            attackLine.setAttribute('class', 'attack-line');
            attackLine.setAttribute('stroke', getPlayerColor(attack.playerId));
            attackLine.setAttribute('stroke-width', '3');
            attackLine.setAttribute('stroke-dasharray', '5,5');
            attackLine.setAttribute('pointer-events', 'none');

            // Append attack line to the line group
            svg.lineGroup.appendChild(attackLine);
        }

        function renderMoveAttackLine(action) {
            const { minX, minY } = calculateMapBounds();
            const fromPixel = hexToPixel(action.from.q, action.from.r, minX, minY);
            const toPixel = hexToPixel(action.to.q, action.to.r, minX, minY);

            // Calculate the offset for the double line effect
            const dx = toPixel.x - fromPixel.x;
            const dy = toPixel.y - fromPixel.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            const offsetX = -dy / length * 3; // Adjust the multiplier (e.g., 3) for spacing
            const offsetY = dx / length * 3;

            // First line (offset in one direction)
            const line1 = document.createElementNS(svgNS, 'line');
            line1.setAttribute('x1', fromPixel.x + offsetX);
            line1.setAttribute('y1', fromPixel.y + offsetY);
            line1.setAttribute('x2', toPixel.x + offsetX);
            line1.setAttribute('y2', toPixel.y + offsetY);
            line1.setAttribute('stroke', getPlayerColor(action.playerId));
            line1.setAttribute('stroke-width', '2');
            line1.setAttribute('class', 'move-attack-line');

            // Second line (offset in the opposite direction)
            const line2 = document.createElementNS(svgNS, 'line');
            line2.setAttribute('x1', fromPixel.x - offsetX);
            line2.setAttribute('y1', fromPixel.y - offsetY);
            line2.setAttribute('x2', toPixel.x - offsetX);
            line2.setAttribute('y2', toPixel.y - offsetY);
            line2.setAttribute('stroke', getPlayerColor(action.playerId));
            line2.setAttribute('stroke-width', '2');
            line2.setAttribute('class', 'move-attack-line');

            // Append the lines to the line group
            svg.lineGroup.appendChild(line1);
            svg.lineGroup.appendChild(line2);
        }

        function clearSVG() {
            while (svg.tileGroup.firstChild) {
                svg.tileGroup.removeChild(svg.tileGroup.firstChild);
            }
            while (svg.lineGroup.firstChild) {
                svg.lineGroup.removeChild(svg.lineGroup.firstChild);
            }
            while (svg.unitGroup.firstChild) {
                svg.unitGroup.removeChild(svg.unitGroup.firstChild);
            }
        }

        function hexToPixel(q, r, minX, minY) {
            const size = TILE_SIZE;
            const x = size * Math.sqrt(3) * (q + r / 2);
            const y = size * (3 / 2) * r;
            return { x: x - minX + TILE_SIZE, y: y - minY + TILE_SIZE };
        }

        function calculateMapBounds() {
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;

            for (const key in gameState.grid) {
                const tile = gameState.grid[key];
                const { q, r } = tile;
                const size = TILE_SIZE;
                const x = size * Math.sqrt(3) * (q + r / 2);
                const y = size * (3 / 2) * r;

                if (x < minX) minX = x;
                if (x > maxX) maxX = x;
                if (y < minY) minY = y;
                if (y > maxY) maxY = y;
            }

            return { minX, maxX, minY, maxY };
        }

        function polygonPoints(sides, radius, centerX, centerY) {
            let points = '';
            for (let i = 0; i < sides; i++) {
                const angle_deg = 60 * i - 30;
                const angle_rad = Math.PI / 180 * angle_deg;
                const x = centerX + radius * Math.cos(angle_rad);
                const y = centerY + radius * Math.sin(angle_rad);
                points += `${x},${y} `;
            }
            return points.trim();
        }

        function getPlayerColor(pid) {
            const player = gameState.players.find(p => p.playerId === pid);
            return player ? player.color : '#000000';
        }

        function determineUnits(tile) {
            if (!tile || typeof tile.q === 'undefined' || typeof tile.r === 'undefined') {
                console.warn('Invalid tile provided to determineUnits:', tile);
                return [];
            }
            
            const q = tile.q;
            const r = tile.r;
            const key = `${q},${r}`;

            // Retrieve the units on this tile, with tile data included
            const units = gameState.grid[key]?.units || [];

            // Optional debug to verify if units are being retrieved correctly
            console.log(`Units on tile (${q}, ${r}):`, units);
            
            return units;
        }

        function handleTileClick(event) {
            // Retrieve q and r from the data attributes
            const q = parseInt(event.currentTarget.dataset.q);
            const r = parseInt(event.currentTarget.dataset.r);
            const hex = svg.querySelector(`polygon[data-q="${q}"][data-r="${r}"]`);

            // Construct the key to access the tile from gameState.grid
            const key = `${q},${r}`;
            const targetTile = gameState.grid[key];

            if (!targetTile) {
                log(`Tile (${q}, ${r}) does not exist in the game state.`);
                return;
            }

            // Retrieve the units on the tile, if any
            const units = determineUnits(targetTile);
            hideUnitsPanel();

            if (!actionMode) {
                // Idle state - no action in progress
                // Filter units that belong to the current player
                const playerUnits = units.filter(unit => unit.playerId === playerId);

                if (units.length > 0) {
                    // Populate the Units Panel with units and tile details
                    log("There are units on this tile.");
                    showUnitsPanel();
                    populateUnitsPanel(units, targetTile);
                } else {
                    // Populate the Units Panel with tile details only
                    log("No units on this tile.");
                    showUnitsPanel();
                    populateUnitsPanel([], targetTile);
                    removeAllActionButtons();
                }

                unhighlightAllTiles();
                bringTileToFront(hex, 'yellow');

                if (playerUnits.length === 1) {
                    // Single unit scenario
                    const unit = playerUnits[0];
                    showUnitActionButtons(unit);
                }
            } else {
                // An action is in progress
                if (!currentActionDef) {
                    log(`No action definition found for action mode ${actionMode}.`);
                    return;
                }

                // For all actions, build movementPath
                const lastTile = movementPath[movementPath.length - 1];
                const distance = hexDistance(lastTile, targetTile);

                if (distance !== 1) {
                    log(`Selected tile (${q}, ${r}) is not adjacent to the last tile.`);
                    return;
                }

                movementPath.push(targetTile);
                highlightTile(hex, currentActionDef.color);

                if (movementPath.length - 1 >= currentActionDef.maxRange) {
                    // Reached maximum range
                    finalizeAction();
                } else {
                    log(`Selected tile (${q}, ${r}). You can select ${currentActionDef.maxRange - (movementPath.length - 1)} more tiles.`);
                    highlightPossibleTiles(); // Update possible tiles
                }
            }
        }

        function showUnitsPanel() {
            const unitsPanel = gameContainer.unitsPanel;
            if (unitsPanel) {
                console.log('show units panel')
                unitsPanel.style.display = 'block'; // Show the panel
            }
        }

        function hideUnitsPanel() {
            const unitsPanel = gameContainer.unitsPanel;
            if (unitsPanel) {
                unitsPanel.style.display = 'none'; // Hide the panel
            }
        }

        function unhighlightAllTiles() { 
            const highlightedTiles = svg.querySelectorAll('.hex.highlighted, .hex.tile-possible, .hex.tile-selected');
            highlightedTiles.forEach(tile => {
                const q = parseInt(tile.dataset.q);
                const r = parseInt(tile.dataset.r);
                const key = `${q},${r}`;
                const gameTile = gameState.grid[key];
                //console.log(key)
                //console.log(gameTile.color)
                if (gameTile) {
                    tile.style.fill = gameTile.color; // Properly set fill color to the tile color in game state
                    tile.style.fillOpacity = 1.0; // Ensure opacity is fully reset
                }
                tile.classList.remove('highlighted', 'tile-possible', 'tile-selected');
                tile.style.strokeWidth = '2';
                tile.style.stroke = '#000'; // Reset to default stroke color
            });
        }

        // Function to populate the Units Panel with both unit and tile details
        function populateUnitsPanel(units, tile) {
            const unitsList = document.getElementById('units-list');
            unitsList.innerHTML = ''; // Clear existing list

            // Add Tile Details at the top of the panel
            const tileDetails = document.createElement('li');
            tileDetails.classList.add('tile-details');
            tileDetails.innerHTML = `
                <strong>Tile Details:</strong><br>
                Type: ${tile.type || 'Default'}<br>
                Resources: ${(tile.resources || []).join(', ') || 'None'}<br>
                Actions: ${(tile.actions || []).map(a => a.type).join(', ') || 'None'}
            `;
            unitsList.appendChild(tileDetails);

            if (units.length === 0) {
                const noUnits = document.createElement('li');
                noUnits.textContent = 'No units on this tile.';
                unitsList.appendChild(noUnits);
                return;
            }

            // Add Unit Details below the tile details
            units.forEach(unit => {
                const unitItem = document.createElement('li');
                unitItem.classList.add('unit-item');
                unitItem.classList.add(unit.playerId === playerId ? 'your-unit' : 'other-unit');

                if (unit.playerId !== playerId) {
                    unitItem.classList.add('disabled');
                }

                unitItem.dataset.unitId = unit.unitId;

                // Check if an action was already recorded for this unit
                const hasAction = gameState.playerActions[playerId - 1]?.some(action => action.unitId === unit.unitId);
                if (hasAction) {
                    unitItem.style.border = '3px solid green';  // Highlight the border in green
                }

                // Unit Details
                const unitDetails = document.createElement('div');
                unitDetails.innerHTML = `
                    <strong>${unit.type} ${unit.unitId}</strong><br>
                    Strength: <span>${unit.strength}</span><br>
                    Power: <span>${unit.power}</span>
                `;
                unitItem.appendChild(unitDetails);

                // Add color indicator
                const colorIndicator = document.createElement('span');
                colorIndicator.classList.add('color-indicator');
                colorIndicator.style.backgroundColor = getPlayerColor(unit.playerId);
                unitItem.appendChild(colorIndicator);

                // Add event listener for player's own units
                if (unit.playerId === playerId) {
                    unitItem.addEventListener('click', () => {
                        selectUnit(unit, unitItem);
                    });
                }

                unitsList.appendChild(unitItem);
            });
        }

        // Currently selected unit
        let selectedUnitForAction = null;

        // Function to handle unit selection
        function selectUnit(unit, unitElement) {
            // Deselect any previously selected unit
            const previouslySelected = document.querySelector('.unit-item.selected');
            if (previouslySelected) {
                previouslySelected.classList.remove('selected');
            }

            // Select the new unit
            unitElement.classList.add('selected');
            selectedUnitForAction = unit;

            log(`Selected Unit ${unit.unitId}. Choose an action.`);

            // Show action buttons for the selected unit
            showUnitActionButtons(unit);
        }

        function showUnitActionButtons(unit) {
            // Remove existing action buttons if any
            removeAllActionButtons();

            const actionButtonsContainer = createContainer('action-buttons', {
                top: '10px',
                left: '220px', // Adjusted to avoid overlapping with the Units Panel
                gap: '10px',
                display: 'flex',
                flexDirection: 'column',
                width: '200px'
            });
            actionButtonsContainer.classList.add('action-buttons');

            // Retrieve available actions for the unit type
            const availableActions = unit.actions.map(actionKey => window.ACTIONS[actionKey]).filter(Boolean);

            // Group actions by their type
            const actionsByType = {};
            availableActions.forEach(action => {
                if (!actionsByType[action.type]) {
                    actionsByType[action.type] = [];
                }
                actionsByType[action.type].push(action);
            });

            // For each action type, create a group container
            for (const actionType in actionsByType) {
                const actionGroup = document.createElement('div');
                actionGroup.classList.add('action-group');
                actionGroup.style.border = '1px solid #ccc';
                actionGroup.style.padding = '10px';
                actionGroup.style.marginBottom = '10px';
                actionGroup.style.position = 'relative';
                actionGroup.style.borderRadius = '5px'; // Rounded corners

                // Add the type label in the top right corner
                const typeLabel = document.createElement('div');
                typeLabel.classList.add('type-label');
                typeLabel.textContent = capitalizeFirstLetter(actionType);
                typeLabel.style.position = 'absolute';
                typeLabel.style.top = '-12px';
                typeLabel.style.backgroundColor = '#fff';
                typeLabel.style.padding = '0 5px';
                typeLabel.style.fontWeight = 'bold';
                typeLabel.style.color = '#333'; // Dark text for contrast

                actionGroup.appendChild(typeLabel);

                // Add buttons for actions of this type
                actionsByType[actionType].forEach(actionDef => {
                    const actionButton = document.createElement('button');
                    actionButton.textContent = `${actionDef.name} (${actionDef.powerConsumption})`;
                    actionButton.classList.add('action-button');
                    actionButton.style.backgroundColor = actionDef.color;
                    actionButton.disabled = unit.power < actionDef.powerConsumption;
                    actionButton.title = unit.power < actionDef.powerConsumption ? `Not enough power to ${actionDef.name}.` : '';

                    actionButton.addEventListener('click', () => {
                        if (actionDef.type === 'reload') {
                            // Directly send reload action without selecting a target
                            const action = {
                                unitId: unit.unitId,
                                actionKey: actionDef.key
                            };
                            sendPlayerActions(action);
                            log(`Reloaded unit ${unit.unitId}. Power is now ${unit.power + 1}.`);

                            // Disable the reload button if power reaches max
                            if (unit.power + 1 >= (gameState.maxPower || 5)) {
                                actionButton.disabled = true;
                                actionButton.title = 'Power is already at maximum.';
                            }
                            resetActionMode();
                        } else {
                            // For other actions, set the action mode
                            log(`Select target tiles for ${actionDef.name} with unit ${unit.unitId}.`);
                            setActionMode(actionDef, unit);
                        }
                    });

                    actionGroup.appendChild(actionButton);
                });

                actionButtonsContainer.appendChild(actionGroup);
            }

            // Cancel Button (outside of action groups)
            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'Cancel';
            cancelButton.classList.add('action-button');
            cancelButton.style.backgroundColor = '#757575'; // Grey
            cancelButton.addEventListener('click', () => {
                removeAllActionButtons();
                log("Action canceled.");
                resetActionMode();
                unhighlightAllTiles();
            });
            actionButtonsContainer.appendChild(cancelButton);

            gameContainer.appendChild(actionButtonsContainer);
        }

        // Helper function to capitalize first letter
        function capitalizeFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

        function setActionMode(actionDef, unit) {
            // Remove any existing action buttons
            removeAllActionButtons();

            actionMode = actionDef.type;  // Set actionMode to action type
            selectedUnit = unit;
            currentActionDef = actionDef; // Store the current action definition
            unhighlightAllTiles();

            // Highlight the unit's tile in yellow
            const hex = svg.querySelector(`polygon[data-q="${unit.tile.q}"][data-r="${unit.tile.r}"]`);
            bringTileToFront(hex, 'yellow');

            // Create the action buttons container
            const actionButtonsContainer = createContainer('action-buttons', {
                top: '10px',
                left: '220px',
                gap: '10px',
                display: 'flex',
                flexDirection: 'column',
                width: '200px'
            });
            actionButtonsContainer.classList.add('action-buttons');
            gameContainer.appendChild(actionButtonsContainer);

            // Initialize movement path for all action types
            movementPath = [unit.tile]; // Start with the unit's current tile

            // Provide instructions based on action type
            if (actionMode === 'move') {
                log(`Select up to ${currentActionDef.maxRange} adjacent tiles for movement.`);
            } else if (actionMode === 'move_attack' || actionMode === 'attack') {
                log(`Select target tiles for ${currentActionDef.name}.`);
            }

            // Finish Action Button
            const finishButton = document.createElement('button');
            finishButton.textContent = 'Finish';
            finishButton.classList.add('action-button');
            finishButton.style.backgroundColor = '#4CAF50'; // Green
            finishButton.addEventListener('click', () => {
                if (movementPath.length > 1) {
                    finalizeAction();
                } else {
                    log('No target selected. You need to select at least one tile.');
                }
            });
            actionButtonsContainer.appendChild(finishButton);

            // Cancel Button
            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'Cancel';
            cancelButton.classList.add('action-button');
            cancelButton.style.backgroundColor = '#757575'; // Grey
            cancelButton.addEventListener('click', () => {
                removeAllActionButtons();
                log("Action canceled.");
                resetActionMode();
                unhighlightAllTiles();
            });
            actionButtonsContainer.appendChild(cancelButton);

            // Highlight possible tiles for the first selection
            highlightPossibleTiles();
        }

        function finalizeAction() {
            const pathTiles = movementPath.map(tile => ({ q: tile.q, r: tile.r }));
            const action = {
                unitId: selectedUnit.unitId,
                actionKey: currentActionDef.key,
                path: pathTiles // Send the entire path to the server
            };
            sendPlayerActions(action);
            log(`Planned ${currentActionDef.name} for unit ${selectedUnit.unitId} through tiles: ${pathTiles.map(t => `(${t.q},${t.r})`).join(' -> ')}`);

            // Reset state and UI
            resetActionMode();
        }

        function highlightPossibleTiles() {
            unhighlightAllTiles();

            // Highlight selected tiles in the movement path
            for (let i = 1; i < movementPath.length; i++) {
                const tile = movementPath[i];
                const hex = svg.querySelector(`polygon[data-q="${tile.q}"][data-r="${tile.r}"]`);
                fillTile(hex, currentActionDef.color, 1.0);
                hex.classList.add('tile-selected');
            }

            // Highlight possible adjacent tiles
            const sourceTile = movementPath[movementPath.length - 1];

            for (const neighborKey of getAdjacentTileKeys(sourceTile.q, sourceTile.r)) {
                const neighborTile = gameState.grid[neighborKey];
                if (neighborTile && !movementPath.includes(neighborTile)) {
                    const hex = svg.querySelector(`polygon[data-q="${neighborTile.q}"][data-r="${neighborTile.r}"]`);
                    fillTile(hex, currentActionDef.color, 0.5); // 50% opacity
                    hex.classList.add('tile-possible');
                }
            }

            const tile = movementPath[0];
            const hex = svg.querySelector(`polygon[data-q="${tile.q}"][data-r="${tile.r}"]`);
            bringTileToFront(hex, 'yellow');
        }

        function fillTile(tileElement, color, opacity) {
            tileElement.style.fill = color;
            tileElement.style.fillOpacity = opacity;
            tileElement.style.cursor = 'pointer';
        }

        function resetActionMode() {
            actionMode = null;
            selectedUnit = null;
            currentActionDef = null;
            movementPath = []; // Clear the movement path
            removeAllActionButtons();
            unhighlightAllTiles();
        }

        function getAdjacentTileKeys(q, r) {
            const directions = [
                { dq: +1, dr: 0 },
                { dq: -1, dr: 0 },
                { dq: 0, dr: +1 },
                { dq: 0, dr: -1 },
                { dq: +1, dr: -1 },
                { dq: -1, dr: +1 }
            ];
            const keys = [];
            for (const dir of directions) {
                const neighborQ = q + dir.dq;
                const neighborR = r + dir.dr;
                keys.push(`${neighborQ},${neighborR}`);
            }
            return keys;
        }

        function hexDistance(tile1, tile2) {
            return (Math.abs(tile1.q - tile2.q) + Math.abs(tile1.r - tile2.r) + Math.abs((-tile1.q - tile1.r) - (-tile2.q - tile2.r))) / 2;
        }

        function bringTileToFront(tile, color) {
            // Move the tile's SVG element to the end of its parent container (tileGroup)
            svg.tileGroup.appendChild(tile);
            highlightTile(tile, color);

            // If the tile has units, bring the unit's elements to the front
            const key = `${tile.dataset.q},${tile.dataset.r}`;
            const units = gameState.grid[key]?.units || [];
            const { minX, minY } = calculateMapBounds();
            if (units.length > 0) {
                // Find the center of the tile
                
                const { q, r } = units[0].tile;
                const { x, y } = hexToPixel(q, r, minX, minY);

                // Move all unit elements related to this tile to the front
                const unitElements = svg.unitGroup.querySelectorAll(`circle[cx="${x}"][cy="${y}"]`);
                unitElements.forEach(unitCircle => {
                    svg.unitGroup.appendChild(unitCircle);
                });

                const unitTexts = svg.unitGroup.querySelectorAll(`text[x="${x}"][y="${y + 5}"]`);
                unitTexts.forEach(unitText => {
                    svg.unitGroup.appendChild(unitText);
                });
            }
        }

        function highlightTile(tileElement, color) {
            tileElement.classList.add('highlighted');
            tileElement.style.stroke = color;
            tileElement.style.strokeWidth = '5';
            tileElement.style.cursor = 'pointer';
        }


        function showRestartButton() {
            const restartButton = document.createElement('button');
            restartButton.textContent = 'Restart Game';
            restartButton.classList.add('action-button');
            restartButton.style.position = 'absolute';
            restartButton.style.top = '50%';
            restartButton.style.left = '50%';
            restartButton.style.transform = 'translate(-50%, -50%)';
            restartButton.style.backgroundColor = '#4CAF50';
            restartButton.addEventListener('click', () => {
                restartGame();
            });
            gameContainer.appendChild(restartButton);
        }

        // Log messages to the log container
        function log(message) {
            if (!gameContainer.logContainer) {
                // Create log container if it doesn't exist
                const logContainer = createContainer('log-container', {
                    bottom: '0',
                    left: '0',
                    width: '100%',
                    maxHeight: '100px',
                    overflowY: 'auto',
                    backgroundColor: '#fff',
                    padding: '5px',
                    boxSizing: 'border-box',
                    fontSize: '14px',
                    borderTop: '1px solid #ccc'
                });
                gameContainer.appendChild(logContainer);
                gameContainer.logContainer = logContainer;
            }
            const p = document.createElement('p');
            p.textContent = message;
            gameContainer.logContainer.appendChild(p);
            gameContainer.logContainer.scrollTop = gameContainer.logContainer.scrollHeight;
            console.log(message); // Also log to console for debugging
        }

        function createLog(message) {
            log(message);
        }

        function updateControlButtons() {
            // Example: Enable Execute Turn button if all actions are submitted
            // In this refactored version, this may not be necessary
        }

        function removeAllActionButtons() {
            const actionButtons = document.querySelector('.action-buttons');
            if (actionButtons) {
                gameContainer.removeChild(actionButtons);
            }
        }

        // Function to restart the game
        function restartGame() {
            socket.send(JSON.stringify({ type: 'restart' }));
            log("Requesting game restart...");
        }

        // Initialize the game UI
        initGame();

        // Define the rainbow gradient for multi-player occupancy
        function defineRainbowGradient() {
            const defs = document.createElementNS(svgNS, 'defs');

            const gradient = document.createElementNS(svgNS, 'linearGradient');
            gradient.setAttribute('id', 'rainbowGradient');
            gradient.setAttribute('x1', '0%');
            gradient.setAttribute('y1', '0%');
            gradient.setAttribute('x2', '100%');
            gradient.setAttribute('y2', '0%');

            const colors = [
                { offset: '0%', color: '#FF0000' },    // Red
                { offset: '20%', color: '#FF7F00' },   // Orange
                { offset: '40%', color: '#FFFF00' },   // Yellow
                { offset: '60%', color: '#00FF00' },   // Green
                { offset: '80%', color: '#0000FF' },   // Blue
                { offset: '100%', color: '#8B00FF' }   // Violet
            ];

            colors.forEach(c => {
                const stop = document.createElementNS(svgNS, 'stop');
                stop.setAttribute('offset', c.offset);
                stop.setAttribute('stop-color', c.color);
                gradient.appendChild(stop);
            });

            defs.appendChild(gradient);
            svg.appendChild(defs);
        }

        // Call the function to define the gradient
        defineRainbowGradient();

    </script>
</body>
</html>
