<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hex Conquest</title>
    <style>
        /* Basic Styles */
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            /*overflow: hidden;  Prevent scrolling on the entire viewport */
        }

        #scroll-container {
            width: 100%;
            height: 100%; /* Adjust as needed to support the size of your game board */
            overflow: scroll; /* Allow scrolling within this container */
            position: relative;
        }

        .action-buttons, .control-buttons, .color-selection, .log-container {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            z-index: 2000; /* Higher z-index to ensure visibility */
        }
        /* Control Buttons Container */
        .control-buttons {
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px; /* Space between buttons */
            width: 150px; /* Fixed width for consistency */
        }
        /* Turn Counter Styling */
        .turn-counter {
            text-align: center;
            font-size: 16px;
            font-weight: bold;
            padding: 10px;
        }
        .move-attack-line {
            stroke-linecap: round;
            opacity: 0.8;
        }


        /* Color Selection */
        .color-selection {
            top: 10px;
            left: 220px;
            z-index: 1002; /* Higher than control-buttons */
            padding: 15px;
            border-radius: 8px;
            max-width: 400px;
            display: none; /* Hidden initially */
        }
        /* Log Container */
        .log-container {
            bottom: 0;
            left: 0;
            width: 100%;
            max-height: 150px;
            overflow-y: auto;
            background-color: #fff;
            padding: 5px;
            box-sizing: border-box;
            font-size: 14px;
            border-top: 1px solid #ccc;
        }
        /* Action Buttons Container */
        .action-buttons {
            position: absolute;
            top: 10px;
            left: 220px;
            display: flex;
            flex-direction: column;
            width: 200px;
            z-index: 1001;
        }

        /* Action Group Styling */
        /* Add gap to the action group container */
        .action-group {
            display: flex;
            flex-direction: column;
            gap: 5px; /* Adds a 5px gap between buttons */
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 8px;
            position: relative;
            margin-bottom: 10px;
        }

        /* Type Label Styling */
        .action-group .type-label {
            position: absolute;
            top: -12px;
            left: 10px;
            background-color: #fff;
            padding: 0 5px;
            font-weight: bold;
            color: #333;
        }
        /* Action Buttons Styling */
        .action-button {
            padding: 10px 0; /* Vertical padding for consistent height */
            font-size: 14px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            color: #fff;
            transition: opacity 0.3s;
            width: 100%;
            text-align: center; /* Center text horizontally */
        }
        .action-button:hover:not(:disabled) {
            opacity: 0.8;
        }
        .action-button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        /* SVG Styling */
        svg {
            width: 100%;
            height: 85%;
        }
        .hex {
            stroke: #000;
            stroke-width: 2;
            cursor: pointer;
            transition: fill 0.3s, stroke 0.3s;
        }
        .hex:hover {
            fill: #d0d0d0;
        }
        .hex.highlighted {
            stroke-width: 5;
        }
        .unit {
            pointer-events: none;
        }
        .unit-circle {
            stroke: #000;
            stroke-width: 1;
        }
        .unit-text {
            font-size: 14px; /* Increased font size for better visibility */
            font-weight: bold;
            fill: #fff;
            text-anchor: middle;
            pointer-events: none;
        }
        .trail-line {
            stroke: rgba(0, 0, 0, 0.5);
            stroke-width: 2;
            stroke-dasharray: 4;
        }
        .tile-possible {
            cursor: pointer;
        }

        .tile-selected {
            cursor: pointer;
        }
        /* Styles for Color Selection */
        .color-buttons {
            display: flex;
            flex-direction: row;
            gap: 10px; /* Space between buttons */
            flex-wrap: wrap; /* Wrap to next line if necessary */
            margin-top: 10px;
        }
        .selected-color {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        .selected-color span {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: inline-block;
            border: 2px solid #000;
        }
        .current-player {
            margin-bottom: 10px;
            font-weight: bold;
        }
        .trail-line {
            stroke: rgba(0, 0, 0, 0.5);
            stroke-width: 2;
            stroke-dasharray: 4;
        }

        /* Units Panel Styling */
        .units-panel {
            position: absolute; /* Ensure it's positioned relative to the game-container */
            top: 10px;
            left: 10px;
            width: 200px;
            max-height: 400px;
            overflow-y: auto;
            background-color: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            z-index: 1001; /* Above game board but below modals */
        }
        .units-panel h3 {
            margin-top: 0;
            text-align: center;
            font-size: 16px;
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
        }
        #units-list {
            list-style-type: none;  /* Remove bullet points */
            padding: 0;  /* Remove padding */
            margin: 0;   /* Remove margin */
        }       
        .unit-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 5px;
            margin: 5px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9;
        }
        .unit-item.your-unit {
            background-color: #e0f7fa; /* Light cyan for player's units */
            cursor: pointer;
        }
        .unit-item.other-unit {
            background-color: #f1f1f1;
            color: #888;
        }
        .unit-item.selected {
            border: 2px solid #2196F3;
            background-color: #b3e5fc; /* Slightly darker blue */
        }
        .unit-item.disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .attack-line {
            /*stroke: rgba(255, 0, 0, 0.8);  Red color for attacks */
            stroke-width: 3;
            stroke-dasharray: 5,5;
        }
        .color-indicator {
            width: 15px;              /* Adjusted size for better visibility */
            height: 15px;
            border-radius: 20%;       /* Makes it a perfect circle */
            display: inline-block;
            margin-right: 5px;        /* Space between the indicator and text */
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="scroll-container"></div>
    </div>

    <script>
        // Define constants
        const NUM_PLAYERS = 2;
        const TILE_SIZE = 40; // Tile size
        const HEIGHT_MULTIPLIER = 4; // Adjust this value to control the height effect

        const gameContainer = document.getElementById('game-container');
        const scrollContainer = document.getElementById('scroll-container');

        // Create SVG element for the game board
        const svgNS = "http://www.w3.org/2000/svg";
        let svg = document.createElementNS(svgNS, 'svg');
        scrollContainer.appendChild(svg);

        let gameState = {};
        let playerId = null;
        let playerColor = null;
        let maxPower = 2; // Default max power
        let unitsMap = {}; // Global mapping from tile key to unit
        let selectedActionDef = null;
        let currentActionDef = null;
        let actionMode = null; // 'move' or 'attack'
        let selectedUnit = null;
        let movementPath = []; // Global variable to store the movement path
        let isInitialCenterSet = false;

        // Connect to the WebSocket server

        const socket = new WebSocket('wss://strategy-game.onrender.com'); // render server
        //const socket = new WebSocket('ws://127.0.0.1:8080'); //localhost
        //const socket = new WebSocket('ws://192.168.0.182:8080'); // Joseph's IP
        //const socket = new WebSocket('ws://192.168.0.106:8080'); // Manav's IP
        //const socket = new WebSocket('ws://192.168.0.102:8080'); // Quinn's IP

        // Listen for messages from the server
        socket.addEventListener('message', function (event) {
            const message = JSON.parse(event.data);
            console.log('Message from server:', message);

            if (message.type === 'request_username') {
                // Prompt the user to enter their username
                const username = prompt(message.message);

                if (username && username.trim() !== '') {
                    // Send the entered username back to the server
                    socket.send(JSON.stringify({ type: 'username', username: username.trim() }));
                } else {
                    alert('Username cannot be empty. Please reload and try again.');
                }
            }

            if (message.type === 'reconnected') {
                console.log(message.message); // "Welcome back!"
                playerId = message.playerId; // Update the playerId
            }

            if (message.type === 'welcome') {
                playerId = message.playerId;
                showColorSelection(message.availableColors);
            }

            if (message.type === 'actions_list') {
                // Store the received actions list
                window.ACTIONS = message.actions; // e.g., { move_short: { type: 'move', ... }, ... }
                
                // Store the action order array (each item has { type, color } )
                // Example: [{ type: 'fast move', color: '#0000FF' }, { type: 'fast attack', color: '#FF0000' }, ...]
                window.ACTION_ORDER = message.action_order; 

                console.log('Received ACTIONS list from server:', window.ACTIONS);
                console.log('Received ACTION_ORDER list from server:', window.ACTION_ORDER);

                // If you still want to display the list in the UI:
                createActionOrderList(window.ACTION_ORDER); 
            }

            if (message.type === 'color_selected') {
                playerColor = message.color;
                log(`You selected color ${playerColor}. Waiting for other players...`);
                //updatePlayerInfo(playerId, playerColor);  // Update player info after color selection
            }

            if (message.type === 'color_taken') {
                // Handle color selection from another player
                const { playerId: selectingPlayerId, color } = message;
                if (selectingPlayerId === playerId) {
                    playerColor = color;
                    log(`You selected color ${playerColor}. Waiting for other players...`);
                } else {
                    log(`Player ${selectingPlayerId} selected color ${color}.`);
                    // Update the UI to remove the selected color
                    const colorButtons = document.querySelectorAll('.color-buttons button');
                    colorButtons.forEach(button => {
                        if (button.getAttribute('data-color') === color) {
                            button.disabled = true;
                            button.style.opacity = 0.5; // Dim the button
                        }
                    });
                }                
            }

            if (message.type === 'init') {
                // Not used in this refactored version
            }

            if (message.type === 'update') {
                // Update game state and render
                gameState = message.state;
                updateDisplay();
                // Remove or hide the color selection UI after game starts
                removeColorSelection();
            }

            if (message.type === 'player_action') {
                //console.log(message)
                playerIndex = message.action.playerId - 1
                gameState.playerActions[playerIndex] = message.action.playerAction
                //console.log(gameState.playerActions)
            }

            if (message.type === 'game_over') {
                updateDisplay();
                handleGameOver(message.winner);
            }

            if (message.type === 'error') {
                alert(`Error: ${message.message}`);
            }
        });

        function removeColorSelection() {
            const colorSelection = document.querySelector('.color-selection');
            if (colorSelection) {
                gameContainer.removeChild(colorSelection);
            }
        }

        // Send color selection to the server
        function sendColorSelection(color) {
            const data = {
                type: 'color_selection',
                color: color
            };

            socket.send(JSON.stringify(data));
        }

        // Send player actions to the server
        function sendPlayerActions(actions) {
            socket.send(JSON.stringify({
                type: 'action',
                action: actions
            }));

            // Highlight the unit's border in green after an action is recorded
            const unitItem = document.querySelector(`.unit-item[data-unit-id="${actions.unitId}"]`);
            if (unitItem) {
                unitItem.style.border = '3px solid green';  // Highlight the border in green
            }
        }

        // Handle game over
        function handleGameOver(winnerId) {
            updateDisplay();
            if (winnerId) {
                alert(`Game Over! Player ${winnerId} wins the game!`);
            } else {
                alert(`Game Over! The game ended in a draw or due to turn limit.`);
            }
            // Optionally, display a restart button or disable further interactions
        }

        function createUnitsMap() {
            const map = {};
            gameState.players.forEach(player => {
                player.units.forEach(unit => {
                    const key = `${unit.tile.q},${unit.tile.r}`;
                    if (!map[key]) {
                        map[key] = [];
                    }
                    map[key].push(unit);
                });
            });
            return map;
        }

        // Initialize the game on connection
        function initGame() {
            // Clear existing SVG and UI elements
            if (svg) {
                scrollContainer.removeChild(svg);
            }
            svg = document.createElementNS(svgNS, 'svg');
            scrollContainer.appendChild(svg);
            removeAllUIElements();

            // Create the Units Panel for showing all units in the top-left corner
            const unitsPanel = createContainer('units-panel', {
                position: 'absolute',
                top: '10px',
                left: '10px',
                width: '180px',
                maxHeight: '600px',
                overflowY: 'auto',
                backgroundColor: 'rgba(255, 255, 255, 0.95)',
                padding: '10px',
                borderRadius: '5px',
                boxShadow: '0 0 10px rgba(0, 0, 0, 0.3)',
                zIndex: '1001', // Ensures it's above the game board
            });

            const panelTitle = document.createElement('h3');
            panelTitle.textContent = 'All Units';
            unitsPanel.appendChild(panelTitle);

            const unitsList = document.createElement('ul');
            unitsList.id = 'units-list'; // We will populate this dynamically
            unitsPanel.appendChild(unitsList);

            gameContainer.appendChild(unitsPanel);

            // Create Control Buttons container
            const controlButtonsContainer = createContainer('control-buttons', {
                top: '10px',
                right: '10px',
                display: 'flex',
                flexDirection: 'column',
                //gap: '10px', // Space between buttons
                width: '150px' // Fixed width for consistency
            });
            controlButtonsContainer.classList.add('control-buttons');

            // Added Turn Counter
            const turnCounter = document.createElement('div');
            turnCounter.classList.add('turn-counter'); // Matches the CSS class
            turnCounter.textContent = `Turn: 1`; // Initialize with Turn 1 or appropriate default
            controlButtonsContainer.appendChild(turnCounter);
            // End of Turn Counter

            // Add Player Info element
            const playerInfo = document.createElement('div');
            playerInfo.classList.add('player-info');
            playerInfo.style.textAlign = 'center'; // Center the text
            playerInfo.style.fontSize = '16px';
            playerInfo.style.fontWeight = 'bold';
            playerInfo.style.padding = '10px';
            controlButtonsContainer.appendChild(playerInfo);

            // Create Restart Game button
            const restartButton = document.createElement('button');
            restartButton.textContent = 'Restart Game';
            restartButton.classList.add('action-button');
            restartButton.style.backgroundColor = '#f44336'; // Red
            restartButton.addEventListener('click', () => {
                restartGame();
            });
            controlButtonsContainer.appendChild(restartButton);

            gameContainer.appendChild(controlButtonsContainer);

            // Create Log container
            const logContainer = createContainer('log-container', {
                bottom: '0',
                left: '0',
                width: '100%',
                maxHeight: '100px',
                overflowY: 'auto',
                backgroundColor: '#fff',
                padding: '5px',
                boxSizing: 'border-box',
                fontSize: '14px',
                borderTop: '1px solid #ccc'
            });
            gameContainer.appendChild(logContainer);
            gameContainer.logContainer = logContainer;

            // Create groups for different layers
            const rampGroup = document.createElementNS(svgNS, 'g');  // Group for ramps
            const tileGroup = document.createElementNS(svgNS, 'g');  // Group for tiles
            const lineGroup = document.createElementNS(svgNS, 'g');  // Group for trail and attack lines
            const unitGroup = document.createElementNS(svgNS, 'g');  // Group for units

            svg.appendChild(rampGroup); // Ramps below tiles
            svg.appendChild(tileGroup);
            svg.appendChild(lineGroup);
            svg.appendChild(unitGroup);

            // Store references to these groups
            svg.rampGroup = rampGroup;
            svg.tileGroup = tileGroup;
            svg.lineGroup = lineGroup;
            svg.unitGroup = unitGroup;
        }

        function createActionOrderList(actionOrder) {
            // Locate the control buttons container
            const controlButtonsContainer = document.querySelector('.control-buttons');
            if (!controlButtonsContainer) return; // Safety check

            // Remove any old Action Order UI (optional)
            const oldActionOrderContainer = document.querySelector('.action-order-container');
            if (oldActionOrderContainer) {
                controlButtonsContainer.removeChild(oldActionOrderContainer);
            }

            // Create a container for the action order list
            const actionOrderContainer = document.createElement('div');
            actionOrderContainer.classList.add('action-order-container');
            actionOrderContainer.style.overflowY = 'auto'; // Enable vertical scrolling
            actionOrderContainer.style.maxHeight = '200px'; // Set a maximum height
            actionOrderContainer.style.marginTop = '10px'; // Add some space from the control buttons
            actionOrderContainer.style.padding = '10px';
            actionOrderContainer.style.backgroundColor = '#fff';
            actionOrderContainer.style.border = '1px solid #ccc';
            actionOrderContainer.style.borderRadius = '5px';
            actionOrderContainer.style.boxShadow = '0 0 5px rgba(0, 0, 0, 0.1)';

            // Add a title for the action order list
            const title = document.createElement('h4');
            title.textContent = 'Action Order';
            title.style.margin = '0';
            title.style.marginBottom = '10px';
            title.style.textAlign = 'center';
            actionOrderContainer.appendChild(title);

            // Create a list element
            const list = document.createElement('ul');
            list.style.listStyleType = 'none'; // Remove bullet points
            list.style.padding = '0';          // Remove padding
            list.style.margin = '0';           // Remove margin

            // Populate the list with action order items
            actionOrder.forEach(({ type, color }) => {
                const listItem = document.createElement('li');
                listItem.textContent = type;         // Use the 'type' for display
                listItem.style.padding = '5px 0';    // Spacing between items
                listItem.style.borderBottom = '1px solid #eee';
                listItem.style.color = color;        // Text color from the actionâ€™s color
                listItem.style.fontWeight = 'bold';  // Make it stand out

                list.appendChild(listItem);
            });

            // Append the list to the container
            actionOrderContainer.appendChild(list);

            // Append the action order container to the control buttons container
            controlButtonsContainer.appendChild(actionOrderContainer);
        }

        // Update player info to include collected resources
        function updatePlayerInfo(playerId, playerColor) {
            const playerInfo = document.querySelector('.player-info');
            if (playerInfo) {
                const player = gameState.players.find(p => p.playerId === playerId);
                const resources = player ? player.resources : {};  // Assuming `resources` is an object

                // Create a string representation of the resources object
                const resourceString = Object.keys(resources).map(resourceName => {
                    return `${resourceName}: ${resources[resourceName]}`;
                }).join(', ');

                playerInfo.innerHTML = `
                    <div style="display: flex; align-items: center;">
                        <span class="color-indicator" style="background-color: ${playerColor};"></span>
                        <strong>Player ${playerId}</strong>
                    </div>
                    <div style="margin-top: 5px;">
                        Resources: ${resourceString || 'None'}
                    </div>
                `;
            }
        }


        function removeAllUIElements() {
            // Remove action-buttons
            const actionButtons = document.querySelector('.action-buttons');
            if (actionButtons) {
                gameContainer.removeChild(actionButtons);
            }

            // Remove control-buttons
            const controlButtons = document.querySelector('.control-buttons');
            if (controlButtons) {
                gameContainer.removeChild(controlButtons);
            }

            // Remove color-selection
            const colorSelection = document.querySelector('.color-selection');
            if (colorSelection) {
                gameContainer.removeChild(colorSelection);
            }

            // Remove log-container
            const logContainer = document.querySelector('.log-container');
            if (logContainer) {
                gameContainer.removeChild(logContainer);
            }
        }

        // Function to restart the game
        function restartGame() {
            socket.send(JSON.stringify({ type: 'restart' }));
            log("Requesting game restart...");
        }

        // Create a generic container
        function createContainer(className, styles = {}) {
            const container = document.createElement('div');
            container.classList.add(className);
            Object.assign(container.style, styles);
            return container;
        }

        // Show color selection UI
        function showColorSelection(availableColors) {
            const colorSelectionContainer = createContainer('color-selection', {
                top: '10px',
                left: '10px',
                display: 'flex',
                flexDirection: 'column'
            });

            // Create and append title
            const title = document.createElement('p');
            title.innerHTML = '<strong>Select Your Color, Number of Units, and Unit Strength:</strong>';
            colorSelectionContainer.appendChild(title);

            // Create a container for color buttons with horizontal layout
            const buttonsContainer = document.createElement('div');
            buttonsContainer.classList.add('color-buttons');

            availableColors.forEach((color) => {
                const colorButton = document.createElement('button');
                colorButton.classList.add('action-button');
                colorButton.style.backgroundColor = color;
                colorButton.style.width = '30px';
                colorButton.style.height = '30px';
                colorButton.style.padding = '0'; // Remove padding for uniform size
                colorButton.setAttribute('data-color', color); // Store color in data attribute
                colorButton.title = color;

                colorButton.addEventListener('click', () => {

                    sendColorSelection(color);
                    // Highlight the selected color button
                    colorButton.style.outline = '3px solid black';
                    colorButton.style.border = '2px solid #000';

                    // Disable other buttons
                    buttonsContainer.querySelectorAll('button').forEach(btn => {
                        if (btn !== colorButton) {
                            btn.disabled = true;
                            btn.style.opacity = 0.5;
                        }
                    });
                });

                buttonsContainer.appendChild(colorButton);
            });

            colorSelectionContainer.appendChild(buttonsContainer);

            gameContainer.appendChild(colorSelectionContainer);
        }


        // Update the game display based on the game state
        function updateDisplay() {
            console.log("Updating display...");
            clearSVG();

            // Create unitsMap
            unitsMap = createUnitsMap();

            // Calculate map bounds
            const { minX, maxX, minY, maxY } = calculateMapBounds();

            // Set SVG size and viewBox
            const svgWidth = maxX - minX + TILE_SIZE * 2; // Extra padding
            const svgHeight = maxY - minY + TILE_SIZE * 2; // Extra padding
            svg.setAttribute('width', svgWidth);
            svg.setAttribute('height', svgHeight);
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);

            // Create an array of tiles from gameState.grid
            const tilesArray = Object.values(gameState.grid);

            // Sort tiles by their height in ascending order
            tilesArray.sort((a, b) => a.height - b.height);

            // Iterate over each tile
            for (const tile of tilesArray) {
                const { q, r } = tile;
                const { x, y } = hexToPixel(q, r, minX, minY);
                const points = polygonPoints(6, TILE_SIZE, x, y, tile);

                const hex = document.createElementNS(svgNS, 'polygon');
                hex.setAttribute('points', points);
                hex.setAttribute('class', 'hex');
                hex.dataset.q = q;
                hex.dataset.r = r;
                hex.setAttribute('fill', tile.color);  // Tile type color from server
            
                // Add event listener for player interaction
                hex.addEventListener('click', handleTileClick);

                // Append tile to the tile group
                svg.tileGroup.appendChild(hex);
            }

            renderDefeatedUnits(); // Render defeated units with a red "X"

            // After drawing all tiles
            for (const tile of tilesArray) {
                drawRamps(tile);
            }

            // Group units by tile
            const tileUnitsMap = {};
            gameState.players.forEach(player => {
                player.units.forEach(unit => {
                    const key = `${unit.tile.q},${unit.tile.r}`;
                    if (!tileUnitsMap[key]) {
                        tileUnitsMap[key] = [];
                    }
                    tileUnitsMap[key].push(unit);
                });
            });

            // Render all units per tile
            for (const key in tileUnitsMap) {
                const units = tileUnitsMap[key];
                const [q, r] = key.split(',').map(Number);
                const { x, y } = hexToPixel(q, r, minX, minY);
                renderTileUnits(q, r, units, x, y);
            }

            // Render actions from lastTurnActions
            if (gameState.lastTurnActions && gameState.lastTurnActions.length > 0) {
                gameState.lastTurnActions.forEach(action => {
                    switch (action.type) {
                        case 'move_short':
                        case 'dash':
                        case 'fast_move':
                            renderTrailLine(action);
                            break;
                        case 'attack_short':
                        case 'attack_long':
                        case 'fast_attack':
                        case 'attack_mortar':
                        case 'attack_ray':
                        case 'explode':
                        case 'spit':
                            renderAttackWithLines(action);
                            break;
                        case 'move_attack':
                            renderMoveAttackLine(action);
                            break;
                        case 'attack_blast':
                            renderAttackBlast(action);
                            break;
                        /*case 'explode':
                            renderAttackMortar(action);
                            break;*/
                        // Add cases for other action types if needed
                    }
                });
            }

            // Update Turn Counter
            const turnCounter = document.querySelector('.turn-counter');
            if (turnCounter && typeof gameState.turn !== 'undefined') {
                turnCounter.textContent = `Turn: ${gameState.turn}`;
            }

            if (gameState && gameState.players) {
                    updatePlayerInfo(playerId, getPlayerColor(playerId));
            }

            // Update control buttons if necessary
            updateControlButtons();

            // Center the view on the map
            if (!isInitialCenterSet) {
                const centerX = (svgWidth - scrollContainer.clientWidth) / 2;
                const centerY = (svgHeight - scrollContainer.clientHeight) / 2;
                scrollContainer.scrollLeft = Math.max(0, centerX);
                scrollContainer.scrollTop = Math.max(0, centerY);
                isInitialCenterSet = true;
            }

            // After rendering other game elements
            renderDelayedActions();
        }

        function renderTileUnits(q, r, units, x, y) {
            // Determine if multiple players are on the same tile
            const TILE_LABEL_LIMIT = 5; // Maximum number of unit labels before using a tooltip
            const unitCount = units.length;
            const uniquePlayers = new Set(units.map(unit => unit.playerId));
            let fillColor = '#000'; // Default color (black)

            if (uniquePlayers.size === 1) {
                // Single player on the tile
                const playerId = units[0].playerId;
                fillColor = getPlayerColor(playerId);
            } else {
                // Multiple players on the tile - apply rainbow gradient
                fillColor = 'url(#rainbowGradient)';
            }

            // Create the unit circle
            const unitCircle = document.createElementNS(svgNS, 'circle');
            unitCircle.setAttribute('cx', x);
            unitCircle.setAttribute('cy', y);
            unitCircle.setAttribute('r', TILE_SIZE / 3); // Adjusted radius for visibility
            unitCircle.setAttribute('fill', fillColor);
            unitCircle.setAttribute('class', 'unit unit-circle');

            // Create the unit count text
            const unitText = document.createElementNS(svgNS, 'text');
            unitText.setAttribute('x', x);
            unitText.setAttribute('y', y + 5); // Adjust for vertical centering
            unitText.textContent = unitCount;
            unitText.setAttribute('class', 'unit unit-text');

            if (units.length <= TILE_LABEL_LIMIT) {
                // Add text labels for each unit under the circle
                const labelText = units.map(unit => unit.type[0]).join(' ');
                const unitLabel = document.createElementNS(svgNS, 'text');
                unitLabel.setAttribute('x', x);
                unitLabel.setAttribute('y', y + TILE_SIZE / 2); // Position below the circle
                unitLabel.setAttribute('class', 'unit-label');
                unitLabel.setAttribute('fill', '#000');
                unitLabel.setAttribute('font-size', '10');
                unitLabel.setAttribute('text-anchor', 'middle');
                unitLabel.textContent = labelText;
                svg.unitGroup.appendChild(unitLabel);
            } else {
                // Add tooltip for too many units
                unitCircle.setAttribute(
                    'title',
                    `Units: ${units.map(unit => `${unit.type} (${unit.unitId})`).join(', ')}`
                );
            }

            // Append unit elements to the unit group
            svg.unitGroup.appendChild(unitCircle);
            svg.unitGroup.appendChild(unitText);
        }

        function renderTrailLine(action) {
            const { minX, minY } = calculateMapBounds();
            const fromPixel = hexToPixel(action.from.q, action.from.r, minX, minY);
            const toPixel = hexToPixel(action.to.q, action.to.r, minX, minY);

            const trailLine = document.createElementNS(svgNS, 'line');
            trailLine.setAttribute('x1', fromPixel.x);
            trailLine.setAttribute('y1', fromPixel.y);
            trailLine.setAttribute('x2', toPixel.x);
            trailLine.setAttribute('y2', toPixel.y);
            trailLine.setAttribute('class', 'trail-line');
            trailLine.setAttribute('stroke', getPlayerColor(action.playerId));
            trailLine.setAttribute('stroke-width', '2');
            trailLine.setAttribute('stroke-dasharray', '4');
            trailLine.setAttribute('pointer-events', 'none');

            // Append trail line to the line group
            svg.lineGroup.appendChild(trailLine);
        }

        function renderAttackBlast(action) {
            const { minX, minY } = calculateMapBounds();
            const fromPixel = hexToPixel(action.from.q, action.from.r, minX, minY);
            const aoePixels = action.aoeTiles.map(tile => hexToPixel(tile.q, tile.r, minX, minY));

            // Sort AoE pixels by angle from attacker to maintain consistent shape
            const angles = aoePixels.map(p => Math.atan2(p.y - fromPixel.y, p.x - fromPixel.x));
            const sorted = aoePixels.map((p, i) => ({ p, angle: angles[i] }))
                .sort((a, b) => a.angle - b.angle);

            const sortedAoEPixels = sorted.map(obj => obj.p);

            // Assume sortedAoEPixels[0], sortedAoEPixels[1], sortedAoEPixels[2]
            const p1 = sortedAoEPixels[0];
            const p2 = sortedAoEPixels[1];
            const p3 = sortedAoEPixels[2];

            // Create the path with a curved edge between p1 and p3, using p2 as a control point
            let pathData = `M ${fromPixel.x} ${fromPixel.y} L ${p1.x} ${p1.y} Q ${p2.x} ${p2.y} ${p3.x} ${p3.y} Z`;

            // Create the SVG path element
            const path = document.createElementNS(svgNS, 'path');
            path.setAttribute('d', pathData);
            path.setAttribute('fill', 'rgba(255, 69, 0, 0.5)'); // OrangeRed with transparency
            path.setAttribute('stroke', getPlayerColor(action.playerId)); // OrangeRed
            path.setAttribute('stroke-width', '2');
            path.setAttribute('pointer-events', 'none');

            // Append to the line group
            svg.lineGroup.appendChild(path);
        }

        function renderAttackMortar(action) {
            const { minX, minY } = calculateMapBounds();
            const { x: centerX, y: centerY } = hexToPixel(action.to.q, action.to.r, minX, minY);

            const mortarCircle = document.createElementNS(svgNS, 'circle');
            mortarCircle.setAttribute('cx', centerX);
            mortarCircle.setAttribute('cy', centerY);
            mortarCircle.setAttribute('r', TILE_SIZE * 1.5); // One tile radius
            mortarCircle.setAttribute('fill', 'rgba(255, 69, 0, 0.3)'); // Semi-transparent orange-red
            mortarCircle.setAttribute('stroke', getPlayerColor(action.playerId));
            mortarCircle.setAttribute('stroke-width', '2');
            mortarCircle.setAttribute('pointer-events', 'none');

            // Append to the line group for proper layering
            svg.lineGroup.appendChild(mortarCircle);
        }

        function renderAttackWithLines(action) {
            const { minX, minY } = calculateMapBounds();
            const fromPixel = hexToPixel(action.from.q, action.from.r, minX, minY);

            // Function to calculate the end of the line, stopping short of the center of the tile
            function getLineEnd(start, end, offset) {
                const dx = end.x - start.x;
                const dy = end.y - start.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const scale = (distance - offset) / distance; // Scale factor to stop short
                return {
                    x: start.x + dx * scale,
                    y: start.y + dy * scale,
                };
            }

            // Draw lines to the main target tile
            const targetPixel = hexToPixel(action.to.q, action.to.r, minX, minY);
            const lineEnd = getLineEnd(fromPixel, targetPixel, TILE_SIZE / 3); // Offset the line by a third of the tile size
            drawLineWithCircle(fromPixel, lineEnd, targetPixel, getPlayerColor(action.playerId));

            // Draw lines to AoE tiles
            if(action.aoeTiles && action.aoeTiles.length > 0){
                action.aoeTiles.forEach(aoeTile => {
                    const aoePixel = hexToPixel(aoeTile.q, aoeTile.r, minX, minY);
                    const aoeLineEnd = getLineEnd(fromPixel, aoePixel, TILE_SIZE / 3);
                    drawLineWithCircle(fromPixel, aoeLineEnd, aoePixel, getPlayerColor(action.playerId));
                });
            }
        }

        // Helper function to draw a line and a circle at the end
        function drawLineWithCircle(start, lineEnd, center, color) {
            const line = document.createElementNS(svgNS, 'line');
            line.setAttribute('x1', start.x);
            line.setAttribute('y1', start.y);
            line.setAttribute('x2', lineEnd.x);
            line.setAttribute('y2', lineEnd.y);
            line.setAttribute('stroke', color);
            line.setAttribute('stroke-width', '2');
            line.setAttribute('stroke-dasharray', '5,5');
            line.setAttribute('pointer-events', 'none');

            const circle = document.createElementNS(svgNS, 'circle');
            circle.setAttribute('cx', lineEnd.x);
            circle.setAttribute('cy', lineEnd.y);
            circle.setAttribute('r', TILE_SIZE / 8); // Small circle radius
            circle.setAttribute('fill', color);

            svg.lineGroup.appendChild(line);
            svg.lineGroup.appendChild(circle);
        }

        function renderMoveAttackLine(action) {
            const { minX, minY } = calculateMapBounds();
            const fromPixel = hexToPixel(action.from.q, action.from.r, minX, minY);
            const toPixel = hexToPixel(action.to.q, action.to.r, minX, minY);

            // Calculate the offset for the double line effect
            const dx = toPixel.x - fromPixel.x;
            const dy = toPixel.y - fromPixel.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            const offsetX = -dy / length * 3; // Adjust the multiplier (e.g., 3) for spacing
            const offsetY = dx / length * 3;

            // First line (offset in one direction)
            const line1 = document.createElementNS(svgNS, 'line');
            line1.setAttribute('x1', fromPixel.x + offsetX);
            line1.setAttribute('y1', fromPixel.y + offsetY);
            line1.setAttribute('x2', toPixel.x + offsetX);
            line1.setAttribute('y2', toPixel.y + offsetY);
            line1.setAttribute('stroke', getPlayerColor(action.playerId));
            line1.setAttribute('stroke-width', '2');
            line1.setAttribute('class', 'move-attack-line');

            // Second line (offset in the opposite direction)
            const line2 = document.createElementNS(svgNS, 'line');
            line2.setAttribute('x1', fromPixel.x - offsetX);
            line2.setAttribute('y1', fromPixel.y - offsetY);
            line2.setAttribute('x2', toPixel.x - offsetX);
            line2.setAttribute('y2', toPixel.y - offsetY);
            line2.setAttribute('stroke', getPlayerColor(action.playerId));
            line2.setAttribute('stroke-width', '2');
            line2.setAttribute('class', 'move-attack-line');

            // Append the lines to the line group
            svg.lineGroup.appendChild(line1);
            svg.lineGroup.appendChild(line2);
        }

        function renderDefeatedUnits() {
            if (!gameState.lastTurnDefeatedUnits) {
                return; // No defeated units
            }

            const { minX, minY } = calculateMapBounds();

            gameState.lastTurnDefeatedUnits.forEach(defeatedUnit => {
                const { q, r } = defeatedUnit.tile;
                const { x, y } = hexToPixel(q, r, minX, minY);

                // Create SVG text element for "X"
                const redX = document.createElementNS(svgNS, 'text');
                redX.setAttribute('x', x - TILE_SIZE / 2.5); // Position slightly to the top-left
                redX.setAttribute('y', y - TILE_SIZE / 2.5);
                redX.setAttribute('fill', 'red');
                redX.setAttribute('font-size', TILE_SIZE / 2); // Adjust size
                redX.setAttribute('font-weight', 'bold');
                redX.setAttribute('text-anchor', 'middle');
                redX.setAttribute('dominant-baseline', 'middle');
                redX.textContent = 'X';

                // Append red X to the SVG
                svg.lineGroup.appendChild(redX);
            });
        }

        function renderDelayedActions() {
            if (!gameState.delayedActions || gameState.delayedActions.length === 0) {
                return; // No delayed actions to render
            }

            const { minX, minY } = calculateMapBounds();

            gameState.delayedActions.forEach(delayedAction => {
                const actionData = delayedAction.actionData;
                const aoeTiles = delayedAction.aoeTiles;
                console.log(aoeTiles)
                const path = actionData.path;

                // Draw target on the last tile in the path
                if (path && path.length > 0) {
                    const lastTileCoords = path[path.length - 1];
                    const { q, r } = lastTileCoords;
                    const { x, y } = hexToPixel(q, r, minX, minY);

                    // Draw the main target at the last tile
                    drawTarget(x, y, TILE_SIZE / 2, TILE_SIZE / 4);
                }

                // Draw targets on AoE tiles, if any
                if (aoeTiles && aoeTiles.length > 0) {
                    aoeTiles.forEach(aoeTile => {
                        const { q, r } = aoeTile;
                        console.log(aoeTile)
                        console.log(q)
                        const { x, y } = hexToPixel(q, r, minX, minY);

                        // Draw a smaller target for AoE tiles
                        drawTarget(x, y, TILE_SIZE / 2, TILE_SIZE / 4);
                    });
                }
            });
        }

        function drawTarget(x, y, outerRadius, innerRadius) {
            const targetGroup = document.createElementNS(svgNS, 'g');
            targetGroup.setAttribute('pointer-events', 'none'); // Ensure it doesn't capture mouse events

            // Outer circle
            const outerCircle = document.createElementNS(svgNS, 'circle');
            outerCircle.setAttribute('cx', x);
            outerCircle.setAttribute('cy', y);
            outerCircle.setAttribute('r', outerRadius);
            outerCircle.setAttribute('fill', 'none');
            outerCircle.setAttribute('stroke', 'red');
            outerCircle.setAttribute('stroke-width', '2');

            // Inner circle
            const innerCircle = document.createElementNS(svgNS, 'circle');
            innerCircle.setAttribute('cx', x);
            innerCircle.setAttribute('cy', y);
            innerCircle.setAttribute('r', innerRadius);
            innerCircle.setAttribute('fill', 'none');
            innerCircle.setAttribute('stroke', 'red');
            innerCircle.setAttribute('stroke-width', '2');

            // Cross lines
            const line1 = document.createElementNS(svgNS, 'line');
            line1.setAttribute('x1', x - outerRadius);
            line1.setAttribute('y1', y);
            line1.setAttribute('x2', x + outerRadius);
            line1.setAttribute('y2', y);
            line1.setAttribute('stroke', 'red');
            line1.setAttribute('stroke-width', '2');

            const line2 = document.createElementNS(svgNS, 'line');
            line2.setAttribute('x1', x);
            line2.setAttribute('y1', y - outerRadius);
            line2.setAttribute('x2', x);
            line2.setAttribute('y2', y + outerRadius);
            line2.setAttribute('stroke', 'red');
            line2.setAttribute('stroke-width', '2');

            // Append elements to the group
            targetGroup.appendChild(outerCircle);
            targetGroup.appendChild(innerCircle);
            targetGroup.appendChild(line1);
            targetGroup.appendChild(line2);

            // Append the target group to the SVG overlay group
            svg.lineGroup.appendChild(targetGroup);
        }

        function clearSVG() {
            while (svg.tileGroup.firstChild) {
                svg.tileGroup.removeChild(svg.tileGroup.firstChild);
            }
            while (svg.lineGroup.firstChild) {
                svg.lineGroup.removeChild(svg.lineGroup.firstChild);
            }
            while (svg.unitGroup.firstChild) {
                svg.unitGroup.removeChild(svg.unitGroup.firstChild);
            }
        }

        function hexToPixel(q, r, minX, minY) {
            const size = TILE_SIZE;
            const key = `${q},${r}`;
            const tile = gameState.grid[key];
            const heightAdjustment = tile ? tile.height * HEIGHT_MULTIPLIER : 0;

            const x = size * Math.sqrt(3) * (q + r / 2);
            const y = size * (3 / 2) * r - heightAdjustment;

            return { x: x - minX + TILE_SIZE, y: y - minY + TILE_SIZE };
        }


        function calculateMapBounds() {
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;

            for (const key in gameState.grid) {
                const tile = gameState.grid[key];
                const { q, r } = tile;
                const size = TILE_SIZE;
                const x = size * Math.sqrt(3) * (q + r / 2);
                const y = size * (3 / 2) * r;

                if (x < minX) minX = x;
                if (x > maxX) maxX = x;
                if (y < minY) minY = y;
                if (y > maxY) maxY = y;
            }

            return { minX, maxX, minY, maxY };
        }

        function polygonPoints(sides, radius, centerX, centerY, tile) {
            // Precompute the positions of the vertices
            const vertices = [];
            for (let i = 0; i < sides; i++) {
                const angle_deg = -60 * i + 30;
                const angle_rad = Math.PI / 180 * angle_deg;
                const x = centerX + radius * Math.cos(angle_rad);
                const y = centerY + radius * Math.sin(angle_rad) - (tile.height * HEIGHT_MULTIPLIER);
                vertices.push({ x, y });
            }

            // Adjust the vertices based on enterable edges
            const adjustedVertices = [];
            const inwardFactor = 0.8; // Adjust as needed
            const inwardDistance = radius * (1 - inwardFactor)
            const adjustDistance = radius * (1 - inwardFactor) * Math.cos(Math.PI / 3); // cos(60Â°) factor

            for (let i = 0; i < sides; i++) {
                const prevIndex = (i + sides - 1) % sides;
                const nextIndex = (i + 1) % sides;
                const vertex = vertices[i];
                const prevVertex = vertices[prevIndex];
                const nextVertex = vertices[nextIndex];

                // Edges connected to this vertex
                const edgeBefore = prevIndex; // Edge between prevVertex and vertex
                const edgeAfter = i;          // Edge between vertex and nextVertex

                const edgeBeforeEnterable = tile.enterableFromDirections.includes(edgeBefore);
                const edgeAfterEnterable = tile.enterableFromDirections.includes(edgeAfter);

                let adjustedX = vertex.x;
                let adjustedY = vertex.y;    

                if (edgeBeforeEnterable && edgeAfterEnterable) {
                    // Move the point inward along the bisector
                    console.log(inwardDistance);
                    const inwardVertex = moveCloser(vertex.x, vertex.y, centerX, centerY, inwardDistance);
                    adjustedX = inwardVertex.x;
                    adjustedY = inwardVertex.y;
                } else if (!edgeBeforeEnterable && edgeAfterEnterable) {
                    // Move the point along the direction of the non-enterable edge (edgeBefore)
                    console.log(adjustDistance);
                    const inwardVertex = moveCloser(vertex.x, vertex.y, prevVertex.x, prevVertex.y, inwardDistance);
                    adjustedX = inwardVertex.x;
                    adjustedY = inwardVertex.y;
                } else if (edgeBeforeEnterable && !edgeAfterEnterable) {
                    // Move the point along the direction of the non-enterable edge (edgeAfter)
                    console.log(adjustDistance);
                    const inwardVertex = moveCloser(vertex.x, vertex.y, nextVertex.x, nextVertex.y, inwardDistance);
                    adjustedX = inwardVertex.x;
                    adjustedY = inwardVertex.y;
                }
                // If neither edge is enterable, do not adjust the vertex
                adjustedVertices.push({ x: adjustedX, y: adjustedY });
            }

            // Store the adjusted vertices and center coordinates in the tile
            tile.vertices = adjustedVertices;
            tile.centerX = centerX;
            tile.centerY = centerY - (tile.height * HEIGHT_MULTIPLIER); // Adjusted for height

            // Build the points string
            let points = '';
            for (let i = 0; i < sides; i++) {
                const vertex = adjustedVertices[i];
                points += `${vertex.x},${vertex.y} `;
            }

            return points.trim();
        }

        function moveCloser(x1, y1, x2, y2, distance) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist === 0) return { x: x1, y: y1 };  // Avoid division by zero

            const factor = distance / dist;

            const newX = x1 + dx * factor;
            const newY = y1 + dy * factor;

            return { x: newX, y: newY };
        }

        // Helper function to determine if an edge is enterable from either tile
        function isEdgeEnterable(tile, edgeIndex) {
            // Check if the edge is enterable from this tile
            if (tile.enterableFromDirections.includes(edgeIndex)) {
                return true;
            }

            // Check if the edge is enterable from the adjacent tile
            const adjacentTileInfo = getAdjacentTile(tile.q, tile.r, edgeIndex);
            if (adjacentTileInfo) {
                const adjacentTile = gameState.grid[adjacentTileInfo.key];
                if (adjacentTile && adjacentTile.enterableFromDirections.includes((edgeIndex + 3) % 6)) {
                    return true;
                }
            }

            return false;
        }

        function drawRamps(tile) {
            const { q, r } = tile;
            const center = { x: tile.centerX, y: tile.centerY }; // Assuming you store center coordinates
            const radius = TILE_SIZE;

            // For each enterable direction
            tile.enterableFromDirections.forEach(direction => {
                // Get adjacent tile
                const neighborInfo = getAdjacentTile(q, r, direction);
                const neighborTile = gameState.grid[neighborInfo.key];
                console.log(tile)
                console.log(neighborTile)

                if (neighborTile) {
                    // Check if the neighbor tile is at a lower height
                    if (neighborTile.height < tile.height) {
                        // Get the shared edge between the two tiles
                        const edgeIndex1 = direction;
                        const edgeIndex2 = (direction + 1) % 6;

                        const vertex1_current = tile.vertices[edgeIndex1];
                        const vertex2_current = tile.vertices[edgeIndex2];

                        const vertex1_neighbor = neighborTile.vertices[(direction + 4) % 6];
                        const vertex2_neighbor = neighborTile.vertices[(direction + 3) % 6];

                        // Create a polygon representing the ramp
                        const rampPolygon = document.createElementNS(svgNS, 'polygon');
                        const points = `
                            ${vertex1_current.x},${vertex1_current.y}
                            ${vertex2_current.x},${vertex2_current.y}
                            ${vertex2_neighbor.x},${vertex2_neighbor.y}
                            ${vertex1_neighbor.x},${vertex1_neighbor.y}
                        `;
                        rampPolygon.setAttribute('points', points.trim());
                        rampPolygon.setAttribute('fill', '#888'); // Gray color for the ramp
                        rampPolygon.setAttribute('stroke', '#000');
                        rampPolygon.setAttribute('stroke-width', '1');

                        // Append to the ramp group
                        svg.rampGroup.appendChild(rampPolygon);
                    }
                }
            });
        }

        function getPlayerColor(pid) {
            const player = gameState.players.find(p => p.playerId === pid);
            return player ? player.color : '#000000';
        }

        function determineUnits(tile) {
            if (!tile || typeof tile.q === 'undefined' || typeof tile.r === 'undefined') {
                console.warn('Invalid tile provided to determineUnits:', tile);
                return [];
            }
            
            const q = tile.q;
            const r = tile.r;
            const key = `${q},${r}`;

            // Retrieve the units on this tile, with tile data included
            const units = gameState.grid[key]?.units || [];

            // Optional debug to verify if units are being retrieved correctly
            console.log(`Units on tile (${q}, ${r}):`, units);
            
            return units;
        }

        function handleTileClick(event) {
            // Retrieve q and r from the data attributes
            const q = parseInt(event.currentTarget.dataset.q);
            const r = parseInt(event.currentTarget.dataset.r);
            const hex = svg.querySelector(`polygon[data-q="${q}"][data-r="${r}"]`);

            // Construct the key to access the tile from gameState.grid
            const key = `${q},${r}`;
            const targetTile = gameState.grid[key];

            if (!targetTile) {
                log(`Tile (${q}, ${r}) does not exist in the game state.`);
                return;
            }

            // Retrieve the units on the tile, if any
            const units = determineUnits(targetTile);
            hideUnitsPanel();

            if (!actionMode) {
                // Idle state - no action in progress
                // Filter units that belong to the current player
                const playerUnits = units.filter(unit => unit.playerId === playerId);

                if (units.length > 0) {
                    // Populate the Units Panel with units and tile details
                    log("There are units on this tile.");
                    showUnitsPanel();
                    populateUnitsPanel(units, targetTile);
                } else {
                    // Populate the Units Panel with tile details only
                    log("No units on this tile.");
                    showUnitsPanel();
                    populateUnitsPanel([], targetTile);
                    removeAllActionButtons();
                }

                unhighlightAllTiles();
                bringTileToFront(hex, 'yellow');

                if (playerUnits.length === 1) {
                    // Single unit scenario
                    const unit = playerUnits[0];
                    showUnitActionButtons(unit);
                }
            } else {
                // An action is in progress
                if (!currentActionDef) {
                    log(`No action definition found for action mode ${actionMode}.`);
                    return;
                }

                // For all actions, build movementPath
                const firstTile = movementPath[0];
                const lastTile = movementPath[movementPath.length - 1];
                const distance = hexDistance(lastTile, targetTile);
                const totalDistance = hexDistance(firstTile, targetTile)

                if (distance !== 1) {
                    log(`Selected tile (${q}, ${r}) is not adjacent to the last tile.`);
                    return;
                }

                movementPath.push(targetTile);
                highlightTile(hex, currentActionDef.color);

                if (movementPath.length - 1 >= currentActionDef.maxRange && totalDistance >= currentActionDef.minRange && totalDistance <= currentActionDef.maxRange) {
                    finalizeAction();
                } else if (movementPath.length - 1 >= currentActionDef.maxRange) {
                    // Reached maximum range
                    log(`Selected tile (${q}, ${r}). Select a new path`);
                    resetActionMode();
                } else {
                    log(`Selected tile (${q}, ${r}). You can select ${currentActionDef.maxRange - (movementPath.length - 1)} more tiles.`);
                    highlightPossibleTiles(); // Update possible tiles
                }
            }
        }

        function showUnitsPanel() {
            const unitsPanel = gameContainer.unitsPanel;
            if (unitsPanel) {
                console.log('show units panel')
                unitsPanel.style.display = 'block'; // Show the panel
            }
        }

        function hideUnitsPanel() {
            const unitsPanel = gameContainer.unitsPanel;
            if (unitsPanel) {
                unitsPanel.style.display = 'none'; // Hide the panel
            }
        }

        function unhighlightAllTiles() { 
            const highlightedTiles = svg.querySelectorAll('.hex.highlighted, .hex.tile-possible, .hex.tile-selected');
            highlightedTiles.forEach(tile => {
                const q = parseInt(tile.dataset.q);
                const r = parseInt(tile.dataset.r);
                const key = `${q},${r}`;
                const gameTile = gameState.grid[key];
                //console.log(key)
                //console.log(gameTile.color)
                if (gameTile) {
                    tile.style.fill = gameTile.color; // Properly set fill color to the tile color in game state
                    tile.style.fillOpacity = 1.0; // Ensure opacity is fully reset
                }
                tile.classList.remove('highlighted', 'tile-possible', 'tile-selected');
                tile.style.strokeWidth = '2';
                tile.style.stroke = '#000'; // Reset to default stroke color
            });
        }

        // Function to populate the Units Panel with both unit and tile details
        function populateUnitsPanel(units, tile) {
            const unitsList = document.getElementById('units-list');
            unitsList.innerHTML = ''; // Clear existing list

            // Add Tile Details at the top of the panel
            const tileDetails = document.createElement('li');
            tileDetails.classList.add('tile-details');
            tileDetails.innerHTML = `
                <strong>Tile Details:</strong><br>
                Type: ${tile.type || 'Default'}<br>
                <strong>Extracted:</strong> ${
                    tile.resourceStorage ? formatResourceStorage(tile.resourceStorage) : 'None'
                }<br>
                <strong>Resources:</strong> ${
                    tile.resourceQuantities ? formatResourceQuantities(tile.resourceQuantities) : 'None'
                }
            `;
            unitsList.appendChild(tileDetails);

            if (units.length === 0) {
                const noUnits = document.createElement('li');
                noUnits.textContent = 'No units on this tile.';
                unitsList.appendChild(noUnits);
                return;
            }

            // Add Unit Details below the tile details
            units.forEach(unit => {
                const unitItem = document.createElement('li');
                unitItem.classList.add('unit-item');
                unitItem.classList.add(unit.playerId === playerId ? 'your-unit' : 'other-unit');

                if (unit.playerId !== playerId) {
                    unitItem.classList.add('disabled');
                }

                unitItem.dataset.unitId = unit.unitId;

                // Check if an action was already recorded for this unit
                const hasAction = gameState.playerActions[playerId - 1]?.some(action => action.unitId === unit.unitId);
                if (hasAction) {
                    unitItem.style.border = '3px solid green';  // Highlight the border in green
                }

                // Unit Details
                const unitDetails = document.createElement('div');
                unitDetails.innerHTML = `
                    <strong>${unit.type} ${unit.unitId}</strong><br>
                    Strength: <span>${unit.strength}</span><br>
                    Power: <span>${unit.power}</span>
                `;
                unitItem.appendChild(unitDetails);

                // Set the title attribute for the tooltip
                unitItem.title = `
            Actions: ${unit.actions.join(', ')}
            Passive Actions: ${unit.passiveActions.join(', ')}
                    `.trim();

                // Add color indicator
                const colorIndicator = document.createElement('span');
                colorIndicator.classList.add('color-indicator');
                colorIndicator.style.backgroundColor = getPlayerColor(unit.playerId);
                unitItem.appendChild(colorIndicator);

                // Add event listener for player's own units
                if (unit.playerId === playerId) {
                    unitItem.addEventListener('click', () => {
                        selectUnit(unit, unitItem);
                    });
                }

                unitsList.appendChild(unitItem);
            });
        }

        // Helper function to format resource storage
        function formatResourceStorage(resourceStorage) {
            return Object.entries(resourceStorage)
                .map(([resource, amount]) => `${resource}: ${amount}`)
                .join(', ');
        }

        // Helper function to format resource quantities
        function formatResourceQuantities(resourceQuantities) {
            return Object.entries(resourceQuantities)
                .map(([resource, amount]) => `${resource}: ${amount}`)
                .join(', ');
        }

        // Currently selected unit
        let selectedUnitForAction = null;

        // Function to handle unit selection
        function selectUnit(unit, unitElement) {
            // Deselect any previously selected unit
            const previouslySelected = document.querySelector('.unit-item.selected');
            if (previouslySelected) {
                previouslySelected.classList.remove('selected');
            }

            // Select the new unit
            unitElement.classList.add('selected');
            selectedUnitForAction = unit;

            log(`Selected Unit ${unit.unitId}. Choose an action.`);

            // Show action buttons for the selected unit
            showUnitActionButtons(unit);
        }

        function showUnitActionButtons(unit) {
            // Remove existing action buttons if any
            removeAllActionButtons();

            const actionButtonsContainer = createContainer('action-buttons', {
                top: '10px',
                left: '220px',
                gap: '10px',
                display: 'flex',
                flexDirection: 'column',
                width: '200px'
            });
            actionButtonsContainer.classList.add('action-buttons');

            // Build a map from action type -> { index, color }
            const orderMap = getActionOrderMap();

            // Retrieve active and passive actions
            let availableActions = unit.actions
                .map(actionKey => window.ACTIONS[actionKey])
                .filter(Boolean);
            let passiveActions = (unit.passiveActions || [])
                .map(actionKey => window.ACTIONS[actionKey])
                .filter(Boolean);

            // Sort active actions by the index in actionOrder
            availableActions.sort((a, b) => {
                const aIndex = orderMap[a.type]?.index ?? 9999;
                const bIndex = orderMap[b.type]?.index ?? 9999;
                return aIndex - bIndex;
            });

            // Sort passive actions similarly
            passiveActions.sort((a, b) => {
                const aIndex = orderMap[a.type]?.index ?? 9999;
                const bIndex = orderMap[b.type]?.index ?? 9999;
                return aIndex - bIndex;
            });

            // Define direction names mapping
            const directionNames = {
                0: 'Forward',
                1: 'Forward Left',
                2: 'Backward Left',
                3: 'Backward',
                4: 'Backward Right',
                5: 'Forward Right'
            };

            // Helper to create action buttons
            const createActionButton = (actionDef, isPassive = false) => {
                const actionButton = document.createElement('button');
                actionButton.textContent = `${actionDef.name} (${actionDef.powerConsumption})`;
                actionButton.classList.add('action-button');
                
                // Lookup color from the order map instead of from the actionDef
                const buttonColor = orderMap[actionDef.type]?.color ?? '#ccc';  
                actionButton.style.backgroundColor = buttonColor;

                if (isPassive) {
                    // Passive action styling and disabling
                    actionButton.disabled = true;
                    actionButton.style.border = '2px dashed #999'; // Dashed border
                } else {
                    // Enable active actions if power is sufficient
                    actionButton.disabled = unit.power < actionDef.powerConsumption;
                }

                // Add tooltip for both active and passive actions
                let tooltip = `Action: ${actionDef.name}\nMax Range: ${actionDef.maxRange}`;
                tooltip += `\nPower Consumption: ${actionDef.powerConsumption}`;
                tooltip += `\nType: ${actionDef.type}`;
                if (actionDef.strengthImpact) {
                    tooltip += `\nStrength Impact: ${actionDef.strengthImpact}`;
                }
                if (actionDef.resourceCost) {
                    const resourceLines = Object.entries(actionDef.resourceCost)
                        .map(([resource, amount]) => `${resource}: ${amount}`)
                        .join('\n'); // Create new lines for each resource
                    tooltip += `\nResource Cost:\n${resourceLines}`;
                }
                if (actionDef.areaOfEffect && actionDef.areaOfEffect.directions.length > 0) {
                    const aoeDirs = actionDef.areaOfEffect.directions
                        .map(dir => directionNames[dir] || `Direction ${dir}`)
                        .join(', ');
                    tooltip += `\nArea of Effect Directions: ${aoeDirs}`;
                }
                if (actionDef.applyTo) {
                    tooltip += `\nApplies To: ${actionDef.applyTo}`;
                }
                if (actionDef.self) {
                    tooltip += `\nCan Apply to Self: ${actionDef.self ? 'Yes' : 'No'}`;
                }
                actionButton.title = tooltip;

                // Add click listener for active actions
                if (!isPassive) {
                    actionButton.addEventListener('click', () => {
                        if (actionDef.maxRange === 0) {
                            // Directly send no-range actions without selecting a target
                            const action = {
                                unitId: unit.unitId,
                                actionKey: actionDef.key
                            };
                            sendPlayerActions(action);
                            log(`Unit ${unit.unitId} selected action ${actionDef.key}.`);

                            // Disable the button if power reaches max
                            if (unit.power + 1 >= (gameState.maxPower || 5)) {
                                actionButton.disabled = true;
                                actionButton.title = 'Power is already at maximum.';
                            }
                            resetActionMode();
                        } else {
                            // Set the action mode for range-based actions
                            log(`Select target tiles for ${actionDef.name} with unit ${unit.unitId}.`);
                            setActionMode(actionDef, unit);
                        }
                    });
                }

                return actionButton;
            };

            // Add active action buttons
            if (availableActions.length > 0) {
                const activeGroup = document.createElement('div');
                activeGroup.classList.add('action-group');
                activeGroup.style.border = '1px solid #ccc';
                activeGroup.style.padding = '10px';
                activeGroup.style.marginBottom = '10px';
                activeGroup.style.position = 'relative';
                activeGroup.style.borderRadius = '5px';

                const activeLabel = document.createElement('div');
                activeLabel.classList.add('type-label');
                activeLabel.textContent = 'Active Actions';
                activeLabel.style.position = 'absolute';
                activeLabel.style.top = '-12px';
                activeLabel.style.backgroundColor = '#fff';
                activeLabel.style.padding = '0 5px';
                activeLabel.style.fontWeight = 'bold';
                activeLabel.style.color = '#333';

                activeGroup.appendChild(activeLabel);

                availableActions.forEach(actionDef => {
                    activeGroup.appendChild(createActionButton(actionDef));
                });

                actionButtonsContainer.appendChild(activeGroup);
            }

            // Add passive action buttons
            if (passiveActions.length > 0) {
                const passiveGroup = document.createElement('div');
                passiveGroup.classList.add('action-group');
                passiveGroup.style.border = '1px dashed #999';
                passiveGroup.style.padding = '10px';
                passiveGroup.style.marginBottom = '10px';
                passiveGroup.style.position = 'relative';
                passiveGroup.style.borderRadius = '5px';

                const passiveLabel = document.createElement('div');
                passiveLabel.classList.add('type-label');
                passiveLabel.textContent = 'Passive Actions';
                passiveLabel.style.position = 'absolute';
                passiveLabel.style.top = '-12px';
                passiveLabel.style.backgroundColor = '#fff';
                passiveLabel.style.padding = '0 5px';
                passiveLabel.style.fontWeight = 'bold';
                passiveLabel.style.color = '#333';

                passiveGroup.appendChild(passiveLabel);

                passiveActions.forEach(actionDef => {
                    passiveGroup.appendChild(createActionButton(actionDef, true));
                });

                actionButtonsContainer.appendChild(passiveGroup);
            }

            // Add cancel button
            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'Cancel';
            cancelButton.classList.add('action-button');
            cancelButton.style.backgroundColor = '#757575'; // Grey
            cancelButton.addEventListener('click', () => {
                removeAllActionButtons();
                log("Action canceled.");
                resetActionMode();
                unhighlightAllTiles();
            });
            actionButtonsContainer.appendChild(cancelButton);

            gameContainer.appendChild(actionButtonsContainer);
        }

        function getActionOrderMap() {
            const orderMap = {};
            if (window.ACTION_ORDER) {
                window.ACTION_ORDER.forEach((ao, i) => {
                    // ao = { type: 'move', color: '#0000FF' }, etc.
                    orderMap[ao.type] = { index: i, color: ao.color };
                });
            }
            return orderMap;
        }

        // Helper function to capitalize first letter
        function capitalizeFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

        function setActionMode(actionDef, unit) {
            // Remove any existing action buttons
            removeAllActionButtons();

            actionMode = actionDef.type;  // Set actionMode to action type
            selectedUnit = unit;
            currentActionDef = actionDef; // Store the current action definition
            unhighlightAllTiles();

            // Highlight the unit's tile in yellow
            const hex = svg.querySelector(`polygon[data-q="${unit.tile.q}"][data-r="${unit.tile.r}"]`);
            bringTileToFront(hex, 'yellow');

            // Create the action buttons container
            const actionButtonsContainer = createContainer('action-buttons', {
                top: '10px',
                left: '220px',
                gap: '10px',
                display: 'flex',
                flexDirection: 'column',
                width: '200px'
            });
            actionButtonsContainer.classList.add('action-buttons');
            gameContainer.appendChild(actionButtonsContainer);

            // Initialize movement path for all action types
            movementPath = [unit.tile]; // Start with the unit's current tile

            // Provide instructions based on action type
            if (actionMode === 'move') {
                log(`Select up to ${currentActionDef.maxRange} adjacent tiles for movement.`);
            } else if (actionMode === 'move_attack' || actionMode === 'attack') {
                log(`Select target tiles for ${currentActionDef.name}.`);
            }

            // Finish Action Button
            const finishButton = document.createElement('button');
            finishButton.textContent = 'Finish';
            finishButton.classList.add('action-button');
            finishButton.style.backgroundColor = '#4CAF50'; // Green
            finishButton.addEventListener('click', () => {
                if (movementPath.length > 1) {
                    finalizeAction();
                } else {
                    log('No target selected. You need to select at least one tile.');
                }
            });
            actionButtonsContainer.appendChild(finishButton);

            // Cancel Button
            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'Cancel';
            cancelButton.classList.add('action-button');
            cancelButton.style.backgroundColor = '#757575'; // Grey
            cancelButton.addEventListener('click', () => {
                removeAllActionButtons();
                log("Action canceled.");
                resetActionMode();
                unhighlightAllTiles();
            });
            actionButtonsContainer.appendChild(cancelButton);

            // Highlight possible tiles for the first selection
            highlightPossibleTiles();
        }

        function finalizeAction() {
            const pathTiles = movementPath.map(tile => ({ q: tile.q, r: tile.r }));
            const action = {
                unitId: selectedUnit.unitId,
                actionKey: currentActionDef.key,
                path: pathTiles // Send the entire path to the server
            };
            sendPlayerActions(action);
            log(`Planned ${currentActionDef.name} for unit ${selectedUnit.unitId} through tiles: ${pathTiles.map(t => `(${t.q},${t.r})`).join(' -> ')}`);

            // Reset state and UI
            resetActionMode();
        }

        function highlightPossibleTiles() {
            unhighlightAllTiles();

            // 1) Look up the color from actionOrder based on currentActionDef.type
            const orderMap = getActionOrderMap();
            const actionColor = orderMap[currentActionDef.type]?.color ?? '#ccc';

            // Highlight selected tiles in the movement path
            for (let i = 1; i < movementPath.length; i++) {
                const tile = movementPath[i];
                const hex = svg.querySelector(`polygon[data-q="${tile.q}"][data-r="${tile.r}"]`);
                fillTile(hex, actionColor, 1.0);  // Use the actionOrder color
                hex.classList.add('tile-selected');
            }

            // Highlight possible adjacent tiles
            const sourceTile = movementPath[movementPath.length - 1];
            //console.log(getAdjacentTileKeys(sourceTile.q, sourceTile.r))

            for (const neighborKey of getAdjacentTileKeys(sourceTile.q, sourceTile.r)) {
                const neighborTile = gameState.grid[neighborKey.key];
                if (neighborTile && !movementPath.includes(neighborTile)) {
                    const hex = svg.querySelector(`polygon[data-q="${neighborTile.q}"][data-r="${neighborTile.r}"]`);
                    fillTile(hex, actionColor, 0.5); // 50% opacity
                    hex.classList.add('tile-possible');
                }
            }

            const tile = movementPath[0];
            const hex = svg.querySelector(`polygon[data-q="${tile.q}"][data-r="${tile.r}"]`);
            bringTileToFront(hex, 'yellow');
        }

        function fillTile(tileElement, color, opacity) {
            tileElement.style.fill = color;
            tileElement.style.fillOpacity = opacity;
            tileElement.style.cursor = 'pointer';
        }

        function resetActionMode() {
            actionMode = null;
            selectedUnit = null;
            currentActionDef = null;
            movementPath = []; // Clear the movement path
            removeAllActionButtons();
            unhighlightAllTiles();
        }

        function getAdjacentTileKeys(q, r) {
            const directions = [
                { dq: +1, dr: 0 },    // Direction 0 (East)
                { dq: +1, dr: -1 },   // Direction 1 (Northeast)
                { dq: 0, dr: -1 },    // Direction 2 (Northwest)
                { dq: -1, dr: 0 },    // Direction 3 (West)
                { dq: -1, dr: +1 },   // Direction 4 (Southwest)
                { dq: 0, dr: +1 }     // Direction 5 (Southeast)
            ];
            const keys = [];
            for (let i = 0; i < directions.length; i++) {
                const dir = directions[i];
                const neighborQ = q + dir.dq;
                const neighborR = r + dir.dr;
                const key = `${neighborQ},${neighborR}`;
                keys.push({ key, direction: i, q: neighborQ, r: neighborR });
            }
            return keys;
        }

        // Helper function to get adjacent tile information
        function getAdjacentTile(q, r, direction) {
            const directions = [
                { dq: +1, dr: 0 },    // Direction 0 (East)
                { dq: +1, dr: -1 },   // Direction 1 (Northeast)
                { dq: 0, dr: -1 },    // Direction 2 (Northwest)
                { dq: -1, dr: 0 },    // Direction 3 (West)
                { dq: -1, dr: +1 },   // Direction 4 (Southwest)
                { dq: 0, dr: +1 }     // Direction 5 (Southeast)
            ];
            const dir = directions[direction];
            const neighborQ = q + dir.dq;
            const neighborR = r + dir.dr;
            const key = `${neighborQ},${neighborR}`;
            return { q: neighborQ, r: neighborR, key };
        }

        function hexDistance(tile1, tile2) {
            return (Math.abs(tile1.q - tile2.q) + Math.abs(tile1.r - tile2.r) + Math.abs((-tile1.q - tile1.r) - (-tile2.q - tile2.r))) / 2;
        }

        function bringTileToFront(tile, color) {
            // Move the tile's SVG element to the end of its parent container (tileGroup)
            svg.tileGroup.appendChild(tile);
            highlightTile(tile, color);

            // If the tile has units, bring the unit's elements to the front
            const key = `${tile.dataset.q},${tile.dataset.r}`;
            const units = gameState.grid[key]?.units || [];
            const { minX, minY } = calculateMapBounds();
            if (units.length > 0) {
                // Find the center of the tile
                
                const { q, r } = units[0].tile;
                const { x, y } = hexToPixel(q, r, minX, minY);

                // Move all unit elements related to this tile to the front
                const unitElements = svg.unitGroup.querySelectorAll(`circle[cx="${x}"][cy="${y}"]`);
                unitElements.forEach(unitCircle => {
                    svg.unitGroup.appendChild(unitCircle);
                });

                const unitTexts = svg.unitGroup.querySelectorAll(`text[x="${x}"][y="${y + 5}"]`);
                unitTexts.forEach(unitText => {
                    svg.unitGroup.appendChild(unitText);
                });
            }
        }

        function highlightTile(tileElement, color) {
            tileElement.classList.add('highlighted');
            tileElement.style.stroke = color;
            tileElement.style.strokeWidth = '5';
            tileElement.style.cursor = 'pointer';
        }


        function showRestartButton() {
            const restartButton = document.createElement('button');
            restartButton.textContent = 'Restart Game';
            restartButton.classList.add('action-button');
            restartButton.style.position = 'absolute';
            restartButton.style.top = '50%';
            restartButton.style.left = '50%';
            restartButton.style.transform = 'translate(-50%, -50%)';
            restartButton.style.backgroundColor = '#4CAF50';
            restartButton.addEventListener('click', () => {
                restartGame();
            });
            gameContainer.appendChild(restartButton);
        }

        // Log messages to the log container
        function log(message) {
            if (!gameContainer.logContainer) {
                // Create log container if it doesn't exist
                const logContainer = createContainer('log-container', {
                    bottom: '0',
                    left: '0',
                    width: '100%',
                    maxHeight: '100px',
                    overflowY: 'auto',
                    backgroundColor: '#fff',
                    padding: '5px',
                    boxSizing: 'border-box',
                    fontSize: '14px',
                    borderTop: '1px solid #ccc'
                });
                gameContainer.appendChild(logContainer);
                gameContainer.logContainer = logContainer;
            }
            const p = document.createElement('p');
            p.textContent = message;
            gameContainer.logContainer.appendChild(p);
            gameContainer.logContainer.scrollTop = gameContainer.logContainer.scrollHeight;
            console.log(message); // Also log to console for debugging
        }

        function createLog(message) {
            log(message);
        }

        function updateControlButtons() {
            // Example: Enable Execute Turn button if all actions are submitted
            // In this refactored version, this may not be necessary
        }

        function removeAllActionButtons() {
            const actionButtons = document.querySelector('.action-buttons');
            if (actionButtons) {
                gameContainer.removeChild(actionButtons);
            }
        }

        // Function to restart the game
        function restartGame() {
            socket.send(JSON.stringify({ type: 'restart' }));
            log("Requesting game restart...");
        }

        // Initialize the game UI
        initGame();

        // Define the rainbow gradient for multi-player occupancy
        function defineRainbowGradient() {
            const defs = document.createElementNS(svgNS, 'defs');

            const gradient = document.createElementNS(svgNS, 'linearGradient');
            gradient.setAttribute('id', 'rainbowGradient');
            gradient.setAttribute('x1', '0%');
            gradient.setAttribute('y1', '0%');
            gradient.setAttribute('x2', '100%');
            gradient.setAttribute('y2', '0%');

            const colors = [
                { offset: '0%', color: '#FF0000' },    // Red
                { offset: '20%', color: '#FF7F00' },   // Orange
                { offset: '40%', color: '#FFFF00' },   // Yellow
                { offset: '60%', color: '#00FF00' },   // Green
                { offset: '80%', color: '#0000FF' },   // Blue
                { offset: '100%', color: '#8B00FF' }   // Violet
            ];

            colors.forEach(c => {
                const stop = document.createElementNS(svgNS, 'stop');
                stop.setAttribute('offset', c.offset);
                stop.setAttribute('stop-color', c.color);
                gradient.appendChild(stop);
            });

            defs.appendChild(gradient);
            svg.appendChild(defs);
        }

        // Call the function to define the gradient
        defineRainbowGradient();

    </script>
</body>
</html>
